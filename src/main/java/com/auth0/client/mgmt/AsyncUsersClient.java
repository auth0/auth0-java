/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.auth0.client.mgmt;

import com.auth0.client.mgmt.core.ClientOptions;
import com.auth0.client.mgmt.core.RequestOptions;
import com.auth0.client.mgmt.core.Suppliers;
import com.auth0.client.mgmt.core.SyncPagingIterable;
import com.auth0.client.mgmt.types.CreateUserRequestContent;
import com.auth0.client.mgmt.types.CreateUserResponseContent;
import com.auth0.client.mgmt.types.GetUserRequestParameters;
import com.auth0.client.mgmt.types.GetUserResponseContent;
import com.auth0.client.mgmt.types.ListUsersByEmailRequestParameters;
import com.auth0.client.mgmt.types.ListUsersRequestParameters;
import com.auth0.client.mgmt.types.RegenerateUsersRecoveryCodeResponseContent;
import com.auth0.client.mgmt.types.RevokeUserAccessRequestContent;
import com.auth0.client.mgmt.types.UpdateUserRequestContent;
import com.auth0.client.mgmt.types.UpdateUserResponseContent;
import com.auth0.client.mgmt.types.UserResponseSchema;
import com.auth0.client.mgmt.users.AsyncAuthenticationMethodsClient;
import com.auth0.client.mgmt.users.AsyncAuthenticatorsClient;
import com.auth0.client.mgmt.users.AsyncConnectedAccountsClient;
import com.auth0.client.mgmt.users.AsyncEnrollmentsClient;
import com.auth0.client.mgmt.users.AsyncFederatedConnectionsTokensetsClient;
import com.auth0.client.mgmt.users.AsyncGroupsClient;
import com.auth0.client.mgmt.users.AsyncIdentitiesClient;
import com.auth0.client.mgmt.users.AsyncLogsClient;
import com.auth0.client.mgmt.users.AsyncMultifactorClient;
import com.auth0.client.mgmt.users.AsyncOrganizationsClient;
import com.auth0.client.mgmt.users.AsyncPermissionsClient;
import com.auth0.client.mgmt.users.AsyncRefreshTokenClient;
import com.auth0.client.mgmt.users.AsyncRiskAssessmentsClient;
import com.auth0.client.mgmt.users.AsyncRolesClient;
import com.auth0.client.mgmt.users.AsyncSessionsClient;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

public class AsyncUsersClient {
    protected final ClientOptions clientOptions;

    private final AsyncRawUsersClient rawClient;

    protected final Supplier<AsyncAuthenticationMethodsClient> authenticationMethodsClient;

    protected final Supplier<AsyncAuthenticatorsClient> authenticatorsClient;

    protected final Supplier<AsyncConnectedAccountsClient> connectedAccountsClient;

    protected final Supplier<AsyncEnrollmentsClient> enrollmentsClient;

    protected final Supplier<AsyncFederatedConnectionsTokensetsClient> federatedConnectionsTokensetsClient;

    protected final Supplier<AsyncGroupsClient> groupsClient;

    protected final Supplier<AsyncIdentitiesClient> identitiesClient;

    protected final Supplier<AsyncLogsClient> logsClient;

    protected final Supplier<AsyncMultifactorClient> multifactorClient;

    protected final Supplier<AsyncOrganizationsClient> organizationsClient;

    protected final Supplier<AsyncPermissionsClient> permissionsClient;

    protected final Supplier<AsyncRiskAssessmentsClient> riskAssessmentsClient;

    protected final Supplier<AsyncRolesClient> rolesClient;

    protected final Supplier<AsyncRefreshTokenClient> refreshTokenClient;

    protected final Supplier<AsyncSessionsClient> sessionsClient;

    public AsyncUsersClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
        this.rawClient = new AsyncRawUsersClient(clientOptions);
        this.authenticationMethodsClient = Suppliers.memoize(() -> new AsyncAuthenticationMethodsClient(clientOptions));
        this.authenticatorsClient = Suppliers.memoize(() -> new AsyncAuthenticatorsClient(clientOptions));
        this.connectedAccountsClient = Suppliers.memoize(() -> new AsyncConnectedAccountsClient(clientOptions));
        this.enrollmentsClient = Suppliers.memoize(() -> new AsyncEnrollmentsClient(clientOptions));
        this.federatedConnectionsTokensetsClient =
                Suppliers.memoize(() -> new AsyncFederatedConnectionsTokensetsClient(clientOptions));
        this.groupsClient = Suppliers.memoize(() -> new AsyncGroupsClient(clientOptions));
        this.identitiesClient = Suppliers.memoize(() -> new AsyncIdentitiesClient(clientOptions));
        this.logsClient = Suppliers.memoize(() -> new AsyncLogsClient(clientOptions));
        this.multifactorClient = Suppliers.memoize(() -> new AsyncMultifactorClient(clientOptions));
        this.organizationsClient = Suppliers.memoize(() -> new AsyncOrganizationsClient(clientOptions));
        this.permissionsClient = Suppliers.memoize(() -> new AsyncPermissionsClient(clientOptions));
        this.riskAssessmentsClient = Suppliers.memoize(() -> new AsyncRiskAssessmentsClient(clientOptions));
        this.rolesClient = Suppliers.memoize(() -> new AsyncRolesClient(clientOptions));
        this.refreshTokenClient = Suppliers.memoize(() -> new AsyncRefreshTokenClient(clientOptions));
        this.sessionsClient = Suppliers.memoize(() -> new AsyncSessionsClient(clientOptions));
    }

    /**
     * Get responses with HTTP metadata like headers
     */
    public AsyncRawUsersClient withRawResponse() {
        return this.rawClient;
    }

    /**
     * Retrieve details of users. It is possible to:
     * <ul>
     * <li>Specify a search criteria for users</li>
     * <li>Sort the users to be returned</li>
     * <li>Select the fields to be returned</li>
     * <li>Specify the number of users to retrieve per page and the page index</li>
     * </ul>
     * <p> &lt;!-- only v3 is available --&gt;</p>
     * <p>The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a></p>
     * <p><a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a></p>
     * <p>Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.</p>
     * <p>Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.</p>
     */
    public CompletableFuture<SyncPagingIterable<UserResponseSchema>> list() {
        return this.rawClient.list().thenApply(response -> response.body());
    }

    /**
     * Retrieve details of users. It is possible to:
     * <ul>
     * <li>Specify a search criteria for users</li>
     * <li>Sort the users to be returned</li>
     * <li>Select the fields to be returned</li>
     * <li>Specify the number of users to retrieve per page and the page index</li>
     * </ul>
     * <p> &lt;!-- only v3 is available --&gt;</p>
     * <p>The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a></p>
     * <p><a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a></p>
     * <p>Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.</p>
     * <p>Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.</p>
     */
    public CompletableFuture<SyncPagingIterable<UserResponseSchema>> list(RequestOptions requestOptions) {
        return this.rawClient.list(requestOptions).thenApply(response -> response.body());
    }

    /**
     * Retrieve details of users. It is possible to:
     * <ul>
     * <li>Specify a search criteria for users</li>
     * <li>Sort the users to be returned</li>
     * <li>Select the fields to be returned</li>
     * <li>Specify the number of users to retrieve per page and the page index</li>
     * </ul>
     * <p> &lt;!-- only v3 is available --&gt;</p>
     * <p>The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a></p>
     * <p><a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a></p>
     * <p>Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.</p>
     * <p>Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.</p>
     */
    public CompletableFuture<SyncPagingIterable<UserResponseSchema>> list(ListUsersRequestParameters request) {
        return this.rawClient.list(request).thenApply(response -> response.body());
    }

    /**
     * Retrieve details of users. It is possible to:
     * <ul>
     * <li>Specify a search criteria for users</li>
     * <li>Sort the users to be returned</li>
     * <li>Select the fields to be returned</li>
     * <li>Specify the number of users to retrieve per page and the page index</li>
     * </ul>
     * <p> &lt;!-- only v3 is available --&gt;</p>
     * <p>The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a></p>
     * <p><a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a></p>
     * <p>Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.</p>
     * <p>Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.</p>
     */
    public CompletableFuture<SyncPagingIterable<UserResponseSchema>> list(
            ListUsersRequestParameters request, RequestOptions requestOptions) {
        return this.rawClient.list(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Create a new user for a given <a href="https://auth0.com/docs/connections/database">database</a> or <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connection.
     * <p>Note: <code>connection</code> is required but other parameters such as <code>email</code> and <code>password</code> are dependent upon the type of connection.</p>
     */
    public CompletableFuture<CreateUserResponseContent> create(CreateUserRequestContent request) {
        return this.rawClient.create(request).thenApply(response -> response.body());
    }

    /**
     * Create a new user for a given <a href="https://auth0.com/docs/connections/database">database</a> or <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connection.
     * <p>Note: <code>connection</code> is required but other parameters such as <code>email</code> and <code>password</code> are dependent upon the type of connection.</p>
     */
    public CompletableFuture<CreateUserResponseContent> create(
            CreateUserRequestContent request, RequestOptions requestOptions) {
        return this.rawClient.create(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Find users by email. If Auth0 is the identity provider (idP), the email address associated with a user is saved in lower case, regardless of how you initially provided it.
     * <p>For example, if you register a user as JohnSmith@example.com, Auth0 saves the user's email as johnsmith@example.com.</p>
     * <p>Therefore, when using this endpoint, make sure that you are searching for users via email addresses using the correct case.</p>
     */
    public CompletableFuture<List<UserResponseSchema>> listUsersByEmail(ListUsersByEmailRequestParameters request) {
        return this.rawClient.listUsersByEmail(request).thenApply(response -> response.body());
    }

    /**
     * Find users by email. If Auth0 is the identity provider (idP), the email address associated with a user is saved in lower case, regardless of how you initially provided it.
     * <p>For example, if you register a user as JohnSmith@example.com, Auth0 saves the user's email as johnsmith@example.com.</p>
     * <p>Therefore, when using this endpoint, make sure that you are searching for users via email addresses using the correct case.</p>
     */
    public CompletableFuture<List<UserResponseSchema>> listUsersByEmail(
            ListUsersByEmailRequestParameters request, RequestOptions requestOptions) {
        return this.rawClient.listUsersByEmail(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     */
    public CompletableFuture<GetUserResponseContent> get(String id) {
        return this.rawClient.get(id).thenApply(response -> response.body());
    }

    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     */
    public CompletableFuture<GetUserResponseContent> get(String id, RequestOptions requestOptions) {
        return this.rawClient.get(id, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     */
    public CompletableFuture<GetUserResponseContent> get(String id, GetUserRequestParameters request) {
        return this.rawClient.get(id, request).thenApply(response -> response.body());
    }

    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     */
    public CompletableFuture<GetUserResponseContent> get(
            String id, GetUserRequestParameters request, RequestOptions requestOptions) {
        return this.rawClient.get(id, request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Delete a user by user ID. This action cannot be undone. For Auth0 Dashboard instructions, see <a href="https://auth0.com/docs/manage-users/user-accounts/delete-users">Delete Users</a>.
     */
    public CompletableFuture<Void> delete(String id) {
        return this.rawClient.delete(id).thenApply(response -> response.body());
    }

    /**
     * Delete a user by user ID. This action cannot be undone. For Auth0 Dashboard instructions, see <a href="https://auth0.com/docs/manage-users/user-accounts/delete-users">Delete Users</a>.
     */
    public CompletableFuture<Void> delete(String id, RequestOptions requestOptions) {
        return this.rawClient.delete(id, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Update a user.
     * <p>These are the attributes that can be updated at the root level:</p>
     * <p><ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul></p>
     * <p>Some considerations:</p>
     * <p><ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the &quot;Unblock a user&quot; endpoint from the &quot;User Blocks&quot; API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul></p>
     * <p><h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ &quot;email_verified&quot;: true }</code></pre></p>
     * <p><h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ &quot;user_metadata&quot; : { &quot;profileCode&quot;: 1479 } }</code></pre></p>
     * <p>To add the field <code>addresses</code> the body to send should be:</p>
     * <p><pre><code>{ &quot;user_metadata&quot; : { &quot;addresses&quot;: {&quot;work_address&quot;: &quot;100 Industrial Way&quot;} }}</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     * &quot;user_metadata&quot;: {
     * &quot;profileCode&quot;: 1479,
     * &quot;addresses&quot;: { &quot;work_address&quot;: &quot;100 Industrial Way&quot; }
     * }
     * }</code></pre></p>
     * <p><h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>&quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:</p>
     * <p><pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;profileCode&quot;: 1479,
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     */
    public CompletableFuture<UpdateUserResponseContent> update(String id) {
        return this.rawClient.update(id).thenApply(response -> response.body());
    }

    /**
     * Update a user.
     * <p>These are the attributes that can be updated at the root level:</p>
     * <p><ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul></p>
     * <p>Some considerations:</p>
     * <p><ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the &quot;Unblock a user&quot; endpoint from the &quot;User Blocks&quot; API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul></p>
     * <p><h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ &quot;email_verified&quot;: true }</code></pre></p>
     * <p><h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ &quot;user_metadata&quot; : { &quot;profileCode&quot;: 1479 } }</code></pre></p>
     * <p>To add the field <code>addresses</code> the body to send should be:</p>
     * <p><pre><code>{ &quot;user_metadata&quot; : { &quot;addresses&quot;: {&quot;work_address&quot;: &quot;100 Industrial Way&quot;} }}</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     * &quot;user_metadata&quot;: {
     * &quot;profileCode&quot;: 1479,
     * &quot;addresses&quot;: { &quot;work_address&quot;: &quot;100 Industrial Way&quot; }
     * }
     * }</code></pre></p>
     * <p><h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>&quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:</p>
     * <p><pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;profileCode&quot;: 1479,
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     */
    public CompletableFuture<UpdateUserResponseContent> update(String id, RequestOptions requestOptions) {
        return this.rawClient.update(id, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Update a user.
     * <p>These are the attributes that can be updated at the root level:</p>
     * <p><ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul></p>
     * <p>Some considerations:</p>
     * <p><ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the &quot;Unblock a user&quot; endpoint from the &quot;User Blocks&quot; API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul></p>
     * <p><h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ &quot;email_verified&quot;: true }</code></pre></p>
     * <p><h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ &quot;user_metadata&quot; : { &quot;profileCode&quot;: 1479 } }</code></pre></p>
     * <p>To add the field <code>addresses</code> the body to send should be:</p>
     * <p><pre><code>{ &quot;user_metadata&quot; : { &quot;addresses&quot;: {&quot;work_address&quot;: &quot;100 Industrial Way&quot;} }}</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     * &quot;user_metadata&quot;: {
     * &quot;profileCode&quot;: 1479,
     * &quot;addresses&quot;: { &quot;work_address&quot;: &quot;100 Industrial Way&quot; }
     * }
     * }</code></pre></p>
     * <p><h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>&quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:</p>
     * <p><pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;profileCode&quot;: 1479,
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     */
    public CompletableFuture<UpdateUserResponseContent> update(String id, UpdateUserRequestContent request) {
        return this.rawClient.update(id, request).thenApply(response -> response.body());
    }

    /**
     * Update a user.
     * <p>These are the attributes that can be updated at the root level:</p>
     * <p><ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul></p>
     * <p>Some considerations:</p>
     * <p><ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the &quot;Unblock a user&quot; endpoint from the &quot;User Blocks&quot; API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul></p>
     * <p><h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ &quot;email_verified&quot;: true }</code></pre></p>
     * <p><h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ &quot;user_metadata&quot; : { &quot;profileCode&quot;: 1479 } }</code></pre></p>
     * <p>To add the field <code>addresses</code> the body to send should be:</p>
     * <p><pre><code>{ &quot;user_metadata&quot; : { &quot;addresses&quot;: {&quot;work_address&quot;: &quot;100 Industrial Way&quot;} }}</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     * &quot;user_metadata&quot;: {
     * &quot;profileCode&quot;: 1479,
     * &quot;addresses&quot;: { &quot;work_address&quot;: &quot;100 Industrial Way&quot; }
     * }
     * }</code></pre></p>
     * <p><h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>&quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:</p>
     * <p><pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;profileCode&quot;: 1479,
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     */
    public CompletableFuture<UpdateUserResponseContent> update(
            String id, UpdateUserRequestContent request, RequestOptions requestOptions) {
        return this.rawClient.update(id, request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Remove an existing multi-factor authentication (MFA) <a href="https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa">recovery code</a> and generate a new one. If a user cannot access the original device or account used for MFA enrollment, they can use a recovery code to authenticate.
     */
    public CompletableFuture<RegenerateUsersRecoveryCodeResponseContent> regenerateRecoveryCode(String id) {
        return this.rawClient.regenerateRecoveryCode(id).thenApply(response -> response.body());
    }

    /**
     * Remove an existing multi-factor authentication (MFA) <a href="https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa">recovery code</a> and generate a new one. If a user cannot access the original device or account used for MFA enrollment, they can use a recovery code to authenticate.
     */
    public CompletableFuture<RegenerateUsersRecoveryCodeResponseContent> regenerateRecoveryCode(
            String id, RequestOptions requestOptions) {
        return this.rawClient.regenerateRecoveryCode(id, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     */
    public CompletableFuture<Void> revokeAccess(String id) {
        return this.rawClient.revokeAccess(id).thenApply(response -> response.body());
    }

    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     */
    public CompletableFuture<Void> revokeAccess(String id, RequestOptions requestOptions) {
        return this.rawClient.revokeAccess(id, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     */
    public CompletableFuture<Void> revokeAccess(String id, RevokeUserAccessRequestContent request) {
        return this.rawClient.revokeAccess(id, request).thenApply(response -> response.body());
    }

    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     */
    public CompletableFuture<Void> revokeAccess(
            String id, RevokeUserAccessRequestContent request, RequestOptions requestOptions) {
        return this.rawClient.revokeAccess(id, request, requestOptions).thenApply(response -> response.body());
    }

    public AsyncAuthenticationMethodsClient authenticationMethods() {
        return this.authenticationMethodsClient.get();
    }

    public AsyncAuthenticatorsClient authenticators() {
        return this.authenticatorsClient.get();
    }

    public AsyncConnectedAccountsClient connectedAccounts() {
        return this.connectedAccountsClient.get();
    }

    public AsyncEnrollmentsClient enrollments() {
        return this.enrollmentsClient.get();
    }

    public AsyncFederatedConnectionsTokensetsClient federatedConnectionsTokensets() {
        return this.federatedConnectionsTokensetsClient.get();
    }

    public AsyncGroupsClient groups() {
        return this.groupsClient.get();
    }

    public AsyncIdentitiesClient identities() {
        return this.identitiesClient.get();
    }

    public AsyncLogsClient logs() {
        return this.logsClient.get();
    }

    public AsyncMultifactorClient multifactor() {
        return this.multifactorClient.get();
    }

    public AsyncOrganizationsClient organizations() {
        return this.organizationsClient.get();
    }

    public AsyncPermissionsClient permissions() {
        return this.permissionsClient.get();
    }

    public AsyncRiskAssessmentsClient riskAssessments() {
        return this.riskAssessmentsClient.get();
    }

    public AsyncRolesClient roles() {
        return this.rolesClient.get();
    }

    public AsyncRefreshTokenClient refreshToken() {
        return this.refreshTokenClient.get();
    }

    public AsyncSessionsClient sessions() {
        return this.sessionsClient.get();
    }
}
