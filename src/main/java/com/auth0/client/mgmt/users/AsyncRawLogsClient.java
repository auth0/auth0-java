/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.auth0.client.mgmt.users;

import com.auth0.client.mgmt.core.ClientOptions;
import com.auth0.client.mgmt.core.ManagementApiException;
import com.auth0.client.mgmt.core.ManagementApiHttpResponse;
import com.auth0.client.mgmt.core.ManagementException;
import com.auth0.client.mgmt.core.ObjectMappers;
import com.auth0.client.mgmt.core.QueryStringMapper;
import com.auth0.client.mgmt.core.RequestOptions;
import com.auth0.client.mgmt.core.SyncPagingIterable;
import com.auth0.client.mgmt.errors.BadRequestError;
import com.auth0.client.mgmt.errors.ForbiddenError;
import com.auth0.client.mgmt.errors.TooManyRequestsError;
import com.auth0.client.mgmt.errors.UnauthorizedError;
import com.auth0.client.mgmt.types.Log;
import com.auth0.client.mgmt.types.UserListLogOffsetPaginatedResponseContent;
import com.auth0.client.mgmt.users.types.ListUserLogsRequestParameters;
import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawLogsClient {
    protected final ClientOptions clientOptions;

    public AsyncRawLogsClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Retrieve log events for a specific user.
     * <p>Note: For more information on all possible event types, their respective acronyms and descriptions, see &lt;a href=&quot;https://auth0.com/docs/logs/log-event-type-codes&quot;&gt;Log Event Type Codes&lt;/a&gt;.</p>
     * <p>For more information on the list of fields that can be used in <code>sort</code>, see &lt;a href=&quot;https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields&quot;&gt;Searchable Fields&lt;/a&gt;.</p>
     * <p>Auth0 &lt;a href=&quot;https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations&quot;&gt;limits the number of logs&lt;/a&gt; you can return by search criteria to 100 logs per request. Furthermore, you may only paginate through up to 1,000 search results. If you exceed this threshold, please redefine your search.</p>
     */
    public CompletableFuture<ManagementApiHttpResponse<SyncPagingIterable<Log>>> list(String id) {
        return list(id, ListUserLogsRequestParameters.builder().build());
    }

    /**
     * Retrieve log events for a specific user.
     * <p>Note: For more information on all possible event types, their respective acronyms and descriptions, see &lt;a href=&quot;https://auth0.com/docs/logs/log-event-type-codes&quot;&gt;Log Event Type Codes&lt;/a&gt;.</p>
     * <p>For more information on the list of fields that can be used in <code>sort</code>, see &lt;a href=&quot;https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields&quot;&gt;Searchable Fields&lt;/a&gt;.</p>
     * <p>Auth0 &lt;a href=&quot;https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations&quot;&gt;limits the number of logs&lt;/a&gt; you can return by search criteria to 100 logs per request. Furthermore, you may only paginate through up to 1,000 search results. If you exceed this threshold, please redefine your search.</p>
     */
    public CompletableFuture<ManagementApiHttpResponse<SyncPagingIterable<Log>>> list(
            String id, ListUserLogsRequestParameters request) {
        return list(id, request, null);
    }

    /**
     * Retrieve log events for a specific user.
     * <p>Note: For more information on all possible event types, their respective acronyms and descriptions, see &lt;a href=&quot;https://auth0.com/docs/logs/log-event-type-codes&quot;&gt;Log Event Type Codes&lt;/a&gt;.</p>
     * <p>For more information on the list of fields that can be used in <code>sort</code>, see &lt;a href=&quot;https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields&quot;&gt;Searchable Fields&lt;/a&gt;.</p>
     * <p>Auth0 &lt;a href=&quot;https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations&quot;&gt;limits the number of logs&lt;/a&gt; you can return by search criteria to 100 logs per request. Furthermore, you may only paginate through up to 1,000 search results. If you exceed this threshold, please redefine your search.</p>
     */
    public CompletableFuture<ManagementApiHttpResponse<SyncPagingIterable<Log>>> list(
            String id, ListUserLogsRequestParameters request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("users")
                .addPathSegment(id)
                .addPathSegments("logs");
        QueryStringMapper.addQueryParameter(httpUrl, "page", request.getPage().orElse(0), false);
        QueryStringMapper.addQueryParameter(
                httpUrl, "per_page", request.getPerPage().orElse(50), false);
        if (!request.getSort().isAbsent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "sort", request.getSort().orElse(null), false);
        }
        QueryStringMapper.addQueryParameter(
                httpUrl, "include_totals", request.getIncludeTotals().orElse(true), false);
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ManagementApiHttpResponse<SyncPagingIterable<Log>>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        UserListLogOffsetPaginatedResponseContent parsedResponse = ObjectMappers.JSON_MAPPER.readValue(
                                responseBodyString, UserListLogOffsetPaginatedResponseContent.class);
                        int newPageNumber = request.getPage()
                                .map((Integer page) -> page + 1)
                                .orElse(1);
                        ListUserLogsRequestParameters nextRequest = ListUserLogsRequestParameters.builder()
                                .from(request)
                                .page(newPageNumber)
                                .build();
                        List<Log> result = parsedResponse.getLogs().orElse(Collections.emptyList());
                        future.complete(new ManagementApiHttpResponse<>(
                                new SyncPagingIterable<Log>(true, result, parsedResponse, () -> {
                                    try {
                                        return list(id, nextRequest, requestOptions)
                                                .get()
                                                .body();
                                    } catch (InterruptedException | ExecutionException e) {
                                        throw new RuntimeException(e);
                                    }
                                }),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 429:
                                future.completeExceptionally(new TooManyRequestsError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new ManagementApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ManagementException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ManagementException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
