/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.auth0.client.mgmt;

import com.auth0.client.mgmt.core.ClientOptions;
import com.auth0.client.mgmt.core.RequestOptions;
import com.auth0.client.mgmt.core.Suppliers;
import com.auth0.client.mgmt.core.SyncPagingIterable;
import com.auth0.client.mgmt.types.CreateUserRequestContent;
import com.auth0.client.mgmt.types.CreateUserResponseContent;
import com.auth0.client.mgmt.types.GetUserRequestParameters;
import com.auth0.client.mgmt.types.GetUserResponseContent;
import com.auth0.client.mgmt.types.ListUsersByEmailRequestParameters;
import com.auth0.client.mgmt.types.ListUsersRequestParameters;
import com.auth0.client.mgmt.types.RegenerateUsersRecoveryCodeResponseContent;
import com.auth0.client.mgmt.types.RevokeUserAccessRequestContent;
import com.auth0.client.mgmt.types.UpdateUserRequestContent;
import com.auth0.client.mgmt.types.UpdateUserResponseContent;
import com.auth0.client.mgmt.types.UserResponseSchema;
import com.auth0.client.mgmt.users.AuthenticationMethodsClient;
import com.auth0.client.mgmt.users.AuthenticatorsClient;
import com.auth0.client.mgmt.users.ConnectedAccountsClient;
import com.auth0.client.mgmt.users.EnrollmentsClient;
import com.auth0.client.mgmt.users.FederatedConnectionsTokensetsClient;
import com.auth0.client.mgmt.users.GroupsClient;
import com.auth0.client.mgmt.users.IdentitiesClient;
import com.auth0.client.mgmt.users.LogsClient;
import com.auth0.client.mgmt.users.MultifactorClient;
import com.auth0.client.mgmt.users.OrganizationsClient;
import com.auth0.client.mgmt.users.PermissionsClient;
import com.auth0.client.mgmt.users.RefreshTokenClient;
import com.auth0.client.mgmt.users.RiskAssessmentsClient;
import com.auth0.client.mgmt.users.RolesClient;
import com.auth0.client.mgmt.users.SessionsClient;
import java.util.List;
import java.util.function.Supplier;

public class UsersClient {
    protected final ClientOptions clientOptions;

    private final RawUsersClient rawClient;

    protected final Supplier<AuthenticationMethodsClient> authenticationMethodsClient;

    protected final Supplier<AuthenticatorsClient> authenticatorsClient;

    protected final Supplier<ConnectedAccountsClient> connectedAccountsClient;

    protected final Supplier<EnrollmentsClient> enrollmentsClient;

    protected final Supplier<FederatedConnectionsTokensetsClient> federatedConnectionsTokensetsClient;

    protected final Supplier<GroupsClient> groupsClient;

    protected final Supplier<IdentitiesClient> identitiesClient;

    protected final Supplier<LogsClient> logsClient;

    protected final Supplier<MultifactorClient> multifactorClient;

    protected final Supplier<OrganizationsClient> organizationsClient;

    protected final Supplier<PermissionsClient> permissionsClient;

    protected final Supplier<RiskAssessmentsClient> riskAssessmentsClient;

    protected final Supplier<RolesClient> rolesClient;

    protected final Supplier<RefreshTokenClient> refreshTokenClient;

    protected final Supplier<SessionsClient> sessionsClient;

    public UsersClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
        this.rawClient = new RawUsersClient(clientOptions);
        this.authenticationMethodsClient = Suppliers.memoize(() -> new AuthenticationMethodsClient(clientOptions));
        this.authenticatorsClient = Suppliers.memoize(() -> new AuthenticatorsClient(clientOptions));
        this.connectedAccountsClient = Suppliers.memoize(() -> new ConnectedAccountsClient(clientOptions));
        this.enrollmentsClient = Suppliers.memoize(() -> new EnrollmentsClient(clientOptions));
        this.federatedConnectionsTokensetsClient =
                Suppliers.memoize(() -> new FederatedConnectionsTokensetsClient(clientOptions));
        this.groupsClient = Suppliers.memoize(() -> new GroupsClient(clientOptions));
        this.identitiesClient = Suppliers.memoize(() -> new IdentitiesClient(clientOptions));
        this.logsClient = Suppliers.memoize(() -> new LogsClient(clientOptions));
        this.multifactorClient = Suppliers.memoize(() -> new MultifactorClient(clientOptions));
        this.organizationsClient = Suppliers.memoize(() -> new OrganizationsClient(clientOptions));
        this.permissionsClient = Suppliers.memoize(() -> new PermissionsClient(clientOptions));
        this.riskAssessmentsClient = Suppliers.memoize(() -> new RiskAssessmentsClient(clientOptions));
        this.rolesClient = Suppliers.memoize(() -> new RolesClient(clientOptions));
        this.refreshTokenClient = Suppliers.memoize(() -> new RefreshTokenClient(clientOptions));
        this.sessionsClient = Suppliers.memoize(() -> new SessionsClient(clientOptions));
    }

    /**
     * Get responses with HTTP metadata like headers
     */
    public RawUsersClient withRawResponse() {
        return this.rawClient;
    }

    /**
     * Retrieve details of users. It is possible to:
     * <ul>
     * <li>Specify a search criteria for users</li>
     * <li>Sort the users to be returned</li>
     * <li>Select the fields to be returned</li>
     * <li>Specify the number of users to retrieve per page and the page index</li>
     * </ul>
     * <p> &lt;!-- only v3 is available --&gt;</p>
     * <p>The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a></p>
     * <p><a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a></p>
     * <p>Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.</p>
     * <p>Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.</p>
     */
    public SyncPagingIterable<UserResponseSchema> list() {
        return this.rawClient.list().body();
    }

    /**
     * Retrieve details of users. It is possible to:
     * <ul>
     * <li>Specify a search criteria for users</li>
     * <li>Sort the users to be returned</li>
     * <li>Select the fields to be returned</li>
     * <li>Specify the number of users to retrieve per page and the page index</li>
     * </ul>
     * <p> &lt;!-- only v3 is available --&gt;</p>
     * <p>The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a></p>
     * <p><a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a></p>
     * <p>Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.</p>
     * <p>Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.</p>
     */
    public SyncPagingIterable<UserResponseSchema> list(RequestOptions requestOptions) {
        return this.rawClient.list(requestOptions).body();
    }

    /**
     * Retrieve details of users. It is possible to:
     * <ul>
     * <li>Specify a search criteria for users</li>
     * <li>Sort the users to be returned</li>
     * <li>Select the fields to be returned</li>
     * <li>Specify the number of users to retrieve per page and the page index</li>
     * </ul>
     * <p> &lt;!-- only v3 is available --&gt;</p>
     * <p>The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a></p>
     * <p><a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a></p>
     * <p>Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.</p>
     * <p>Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.</p>
     */
    public SyncPagingIterable<UserResponseSchema> list(ListUsersRequestParameters request) {
        return this.rawClient.list(request).body();
    }

    /**
     * Retrieve details of users. It is possible to:
     * <ul>
     * <li>Specify a search criteria for users</li>
     * <li>Sort the users to be returned</li>
     * <li>Select the fields to be returned</li>
     * <li>Specify the number of users to retrieve per page and the page index</li>
     * </ul>
     * <p> &lt;!-- only v3 is available --&gt;</p>
     * <p>The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a></p>
     * <p><a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a></p>
     * <p>Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.</p>
     * <p>Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.</p>
     */
    public SyncPagingIterable<UserResponseSchema> list(
            ListUsersRequestParameters request, RequestOptions requestOptions) {
        return this.rawClient.list(request, requestOptions).body();
    }

    /**
     * Create a new user for a given <a href="https://auth0.com/docs/connections/database">database</a> or <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connection.
     * <p>Note: <code>connection</code> is required but other parameters such as <code>email</code> and <code>password</code> are dependent upon the type of connection.</p>
     */
    public CreateUserResponseContent create(CreateUserRequestContent request) {
        return this.rawClient.create(request).body();
    }

    /**
     * Create a new user for a given <a href="https://auth0.com/docs/connections/database">database</a> or <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connection.
     * <p>Note: <code>connection</code> is required but other parameters such as <code>email</code> and <code>password</code> are dependent upon the type of connection.</p>
     */
    public CreateUserResponseContent create(CreateUserRequestContent request, RequestOptions requestOptions) {
        return this.rawClient.create(request, requestOptions).body();
    }

    /**
     * Find users by email. If Auth0 is the identity provider (idP), the email address associated with a user is saved in lower case, regardless of how you initially provided it.
     * <p>For example, if you register a user as JohnSmith@example.com, Auth0 saves the user's email as johnsmith@example.com.</p>
     * <p>Therefore, when using this endpoint, make sure that you are searching for users via email addresses using the correct case.</p>
     */
    public List<UserResponseSchema> listUsersByEmail(ListUsersByEmailRequestParameters request) {
        return this.rawClient.listUsersByEmail(request).body();
    }

    /**
     * Find users by email. If Auth0 is the identity provider (idP), the email address associated with a user is saved in lower case, regardless of how you initially provided it.
     * <p>For example, if you register a user as JohnSmith@example.com, Auth0 saves the user's email as johnsmith@example.com.</p>
     * <p>Therefore, when using this endpoint, make sure that you are searching for users via email addresses using the correct case.</p>
     */
    public List<UserResponseSchema> listUsersByEmail(
            ListUsersByEmailRequestParameters request, RequestOptions requestOptions) {
        return this.rawClient.listUsersByEmail(request, requestOptions).body();
    }

    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     */
    public GetUserResponseContent get(String id) {
        return this.rawClient.get(id).body();
    }

    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     */
    public GetUserResponseContent get(String id, RequestOptions requestOptions) {
        return this.rawClient.get(id, requestOptions).body();
    }

    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     */
    public GetUserResponseContent get(String id, GetUserRequestParameters request) {
        return this.rawClient.get(id, request).body();
    }

    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     */
    public GetUserResponseContent get(String id, GetUserRequestParameters request, RequestOptions requestOptions) {
        return this.rawClient.get(id, request, requestOptions).body();
    }

    /**
     * Delete a user by user ID. This action cannot be undone. For Auth0 Dashboard instructions, see <a href="https://auth0.com/docs/manage-users/user-accounts/delete-users">Delete Users</a>.
     */
    public void delete(String id) {
        this.rawClient.delete(id).body();
    }

    /**
     * Delete a user by user ID. This action cannot be undone. For Auth0 Dashboard instructions, see <a href="https://auth0.com/docs/manage-users/user-accounts/delete-users">Delete Users</a>.
     */
    public void delete(String id, RequestOptions requestOptions) {
        this.rawClient.delete(id, requestOptions).body();
    }

    /**
     * Update a user.
     * <p>These are the attributes that can be updated at the root level:</p>
     * <p><ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul></p>
     * <p>Some considerations:</p>
     * <p><ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the &quot;Unblock a user&quot; endpoint from the &quot;User Blocks&quot; API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul></p>
     * <p><h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ &quot;email_verified&quot;: true }</code></pre></p>
     * <p><h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ &quot;user_metadata&quot; : { &quot;profileCode&quot;: 1479 } }</code></pre></p>
     * <p>To add the field <code>addresses</code> the body to send should be:</p>
     * <p><pre><code>{ &quot;user_metadata&quot; : { &quot;addresses&quot;: {&quot;work_address&quot;: &quot;100 Industrial Way&quot;} }}</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     * &quot;user_metadata&quot;: {
     * &quot;profileCode&quot;: 1479,
     * &quot;addresses&quot;: { &quot;work_address&quot;: &quot;100 Industrial Way&quot; }
     * }
     * }</code></pre></p>
     * <p><h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>&quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:</p>
     * <p><pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;profileCode&quot;: 1479,
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     */
    public UpdateUserResponseContent update(String id) {
        return this.rawClient.update(id).body();
    }

    /**
     * Update a user.
     * <p>These are the attributes that can be updated at the root level:</p>
     * <p><ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul></p>
     * <p>Some considerations:</p>
     * <p><ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the &quot;Unblock a user&quot; endpoint from the &quot;User Blocks&quot; API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul></p>
     * <p><h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ &quot;email_verified&quot;: true }</code></pre></p>
     * <p><h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ &quot;user_metadata&quot; : { &quot;profileCode&quot;: 1479 } }</code></pre></p>
     * <p>To add the field <code>addresses</code> the body to send should be:</p>
     * <p><pre><code>{ &quot;user_metadata&quot; : { &quot;addresses&quot;: {&quot;work_address&quot;: &quot;100 Industrial Way&quot;} }}</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     * &quot;user_metadata&quot;: {
     * &quot;profileCode&quot;: 1479,
     * &quot;addresses&quot;: { &quot;work_address&quot;: &quot;100 Industrial Way&quot; }
     * }
     * }</code></pre></p>
     * <p><h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>&quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:</p>
     * <p><pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;profileCode&quot;: 1479,
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     */
    public UpdateUserResponseContent update(String id, RequestOptions requestOptions) {
        return this.rawClient.update(id, requestOptions).body();
    }

    /**
     * Update a user.
     * <p>These are the attributes that can be updated at the root level:</p>
     * <p><ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul></p>
     * <p>Some considerations:</p>
     * <p><ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the &quot;Unblock a user&quot; endpoint from the &quot;User Blocks&quot; API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul></p>
     * <p><h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ &quot;email_verified&quot;: true }</code></pre></p>
     * <p><h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ &quot;user_metadata&quot; : { &quot;profileCode&quot;: 1479 } }</code></pre></p>
     * <p>To add the field <code>addresses</code> the body to send should be:</p>
     * <p><pre><code>{ &quot;user_metadata&quot; : { &quot;addresses&quot;: {&quot;work_address&quot;: &quot;100 Industrial Way&quot;} }}</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     * &quot;user_metadata&quot;: {
     * &quot;profileCode&quot;: 1479,
     * &quot;addresses&quot;: { &quot;work_address&quot;: &quot;100 Industrial Way&quot; }
     * }
     * }</code></pre></p>
     * <p><h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>&quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:</p>
     * <p><pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;profileCode&quot;: 1479,
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     */
    public UpdateUserResponseContent update(String id, UpdateUserRequestContent request) {
        return this.rawClient.update(id, request).body();
    }

    /**
     * Update a user.
     * <p>These are the attributes that can be updated at the root level:</p>
     * <p><ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul></p>
     * <p>Some considerations:</p>
     * <p><ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the &quot;Unblock a user&quot; endpoint from the &quot;User Blocks&quot; API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul></p>
     * <p><h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ &quot;email_verified&quot;: true }</code></pre></p>
     * <p><h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ &quot;user_metadata&quot; : { &quot;profileCode&quot;: 1479 } }</code></pre></p>
     * <p>To add the field <code>addresses</code> the body to send should be:</p>
     * <p><pre><code>{ &quot;user_metadata&quot; : { &quot;addresses&quot;: {&quot;work_address&quot;: &quot;100 Industrial Way&quot;} }}</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     * &quot;user_metadata&quot;: {
     * &quot;profileCode&quot;: 1479,
     * &quot;addresses&quot;: { &quot;work_address&quot;: &quot;100 Industrial Way&quot; }
     * }
     * }</code></pre></p>
     * <p><h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>&quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     * <p>The modified object ends up with the following <code>user_metadata</code> property:</p>
     * <p><pre><code>{
     *   &quot;user_metadata&quot;: {
     *     &quot;profileCode&quot;: 1479,
     *     &quot;addresses&quot;: {
     *       &quot;work_address&quot;: &quot;100 Industrial Way&quot;,
     *       &quot;home_address&quot;: &quot;742 Evergreen Terrace&quot;
     *     }
     *   }
     * }</code></pre></p>
     */
    public UpdateUserResponseContent update(
            String id, UpdateUserRequestContent request, RequestOptions requestOptions) {
        return this.rawClient.update(id, request, requestOptions).body();
    }

    /**
     * Remove an existing multi-factor authentication (MFA) <a href="https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa">recovery code</a> and generate a new one. If a user cannot access the original device or account used for MFA enrollment, they can use a recovery code to authenticate.
     */
    public RegenerateUsersRecoveryCodeResponseContent regenerateRecoveryCode(String id) {
        return this.rawClient.regenerateRecoveryCode(id).body();
    }

    /**
     * Remove an existing multi-factor authentication (MFA) <a href="https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa">recovery code</a> and generate a new one. If a user cannot access the original device or account used for MFA enrollment, they can use a recovery code to authenticate.
     */
    public RegenerateUsersRecoveryCodeResponseContent regenerateRecoveryCode(String id, RequestOptions requestOptions) {
        return this.rawClient.regenerateRecoveryCode(id, requestOptions).body();
    }

    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     */
    public void revokeAccess(String id) {
        this.rawClient.revokeAccess(id).body();
    }

    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     */
    public void revokeAccess(String id, RequestOptions requestOptions) {
        this.rawClient.revokeAccess(id, requestOptions).body();
    }

    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     */
    public void revokeAccess(String id, RevokeUserAccessRequestContent request) {
        this.rawClient.revokeAccess(id, request).body();
    }

    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     */
    public void revokeAccess(String id, RevokeUserAccessRequestContent request, RequestOptions requestOptions) {
        this.rawClient.revokeAccess(id, request, requestOptions).body();
    }

    public AuthenticationMethodsClient authenticationMethods() {
        return this.authenticationMethodsClient.get();
    }

    public AuthenticatorsClient authenticators() {
        return this.authenticatorsClient.get();
    }

    public ConnectedAccountsClient connectedAccounts() {
        return this.connectedAccountsClient.get();
    }

    public EnrollmentsClient enrollments() {
        return this.enrollmentsClient.get();
    }

    public FederatedConnectionsTokensetsClient federatedConnectionsTokensets() {
        return this.federatedConnectionsTokensetsClient.get();
    }

    public GroupsClient groups() {
        return this.groupsClient.get();
    }

    public IdentitiesClient identities() {
        return this.identitiesClient.get();
    }

    public LogsClient logs() {
        return this.logsClient.get();
    }

    public MultifactorClient multifactor() {
        return this.multifactorClient.get();
    }

    public OrganizationsClient organizations() {
        return this.organizationsClient.get();
    }

    public PermissionsClient permissions() {
        return this.permissionsClient.get();
    }

    public RiskAssessmentsClient riskAssessments() {
        return this.riskAssessmentsClient.get();
    }

    public RolesClient roles() {
        return this.rolesClient.get();
    }

    public RefreshTokenClient refreshToken() {
        return this.refreshTokenClient.get();
    }

    public SessionsClient sessions() {
        return this.sessionsClient.get();
    }
}
