/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.auth0.client.mgmt;

import com.auth0.client.mgmt.core.ClientOptions;
import com.auth0.client.mgmt.core.ManagementApiException;
import com.auth0.client.mgmt.core.ManagementApiHttpResponse;
import com.auth0.client.mgmt.core.ManagementException;
import com.auth0.client.mgmt.core.ObjectMappers;
import com.auth0.client.mgmt.core.QueryStringMapper;
import com.auth0.client.mgmt.core.RequestOptions;
import com.auth0.client.mgmt.core.SyncPagingIterable;
import com.auth0.client.mgmt.errors.BadRequestError;
import com.auth0.client.mgmt.errors.ForbiddenError;
import com.auth0.client.mgmt.errors.NotFoundError;
import com.auth0.client.mgmt.errors.TooManyRequestsError;
import com.auth0.client.mgmt.errors.UnauthorizedError;
import com.auth0.client.mgmt.types.GetLogResponseContent;
import com.auth0.client.mgmt.types.ListLogOffsetPaginatedResponseContent;
import com.auth0.client.mgmt.types.ListLogsRequestParameters;
import com.auth0.client.mgmt.types.Log;
import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawLogsClient {
    protected final ClientOptions clientOptions;

    public AsyncRawLogsClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Retrieve log entries that match the specified search criteria (or all log entries if no criteria specified).
     * <p>Set custom search criteria using the <code>q</code> parameter, or search from a specific log ID (<i>&quot;search from checkpoint&quot;</i>).</p>
     * <p>For more information on all possible event types, their respective acronyms, and descriptions, see <a href="https://auth0.com/docs/logs/log-event-type-codes">Log Event Type Codes</a>.</p>
     * <p><h5>To set custom search criteria, use the following parameters:</h5></p>
     * <p><ul>
     *     <li><b>q:</b> Search Criteria using <a href="https://auth0.com/docs/logs/log-search-query-syntax">Query String Syntax</a></li>
     *     <li><b>page:</b> Page index of the results to return. First page is 0.</li>
     *     <li><b>per_page:</b> Number of results per page.</li>
     *     <li><b>sort:</b> Field to use for sorting appended with `:1` for ascending and `:-1` for descending. e.g. `date:-1`</li>
     *     <li><b>fields:</b> Comma-separated list of fields to include or exclude (depending on include_fields) from the result, empty to retrieve all fields.</li>
     *     <li><b>include_fields:</b> Whether specified fields are to be included (true) or excluded (false).</li>
     *     <li><b>include_totals:</b> Return results inside an object that contains the total result count (true) or as a direct array of results (false, default). <b>Deprecated:</b> this field is deprecated and should be removed from use. See <a href="https://auth0.com/docs/product-lifecycle/deprecations-and-migrations/migrate-to-tenant-log-search-v3#pagination">Search Engine V3 Breaking Changes</a></li>
     * </ul></p>
     * <p>For more information on the list of fields that can be used in <code>fields</code> and <code>sort</code>, see <a href="https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields">Searchable Fields</a>.</p>
     * <p>Auth0 <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations">limits the number of logs</a> you can return by search criteria to 100 logs per request. Furthermore, you may paginate only through 1,000 search results. If you exceed this threshold, please redefine your search or use the <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#retrieve-logs-by-checkpoint">get logs by checkpoint method</a>.</p>
     * <p><h5>To search from a checkpoint log ID, use the following parameters:</h5>
     * <ul>
     *     <li><b>from:</b> Log Event ID from which to start retrieving logs. You can limit the number of logs returned using the <code>take</code> parameter. If you use <code>from</code> at the same time as <code>q</code>, <code>from</code> takes precedence and <code>q</code> is ignored.</li>
     *     <li><b>take:</b> Number of entries to retrieve when using the <code>from</code> parameter.</li>
     * </ul></p>
     * <p><strong>Important:</strong> When fetching logs from a checkpoint log ID, any parameter other than <code>from</code> and <code>take</code> will be ignored, and date ordering is not guaranteed.</p>
     */
    public CompletableFuture<ManagementApiHttpResponse<SyncPagingIterable<Log>>> list() {
        return list(ListLogsRequestParameters.builder().build());
    }

    /**
     * Retrieve log entries that match the specified search criteria (or all log entries if no criteria specified).
     * <p>Set custom search criteria using the <code>q</code> parameter, or search from a specific log ID (<i>&quot;search from checkpoint&quot;</i>).</p>
     * <p>For more information on all possible event types, their respective acronyms, and descriptions, see <a href="https://auth0.com/docs/logs/log-event-type-codes">Log Event Type Codes</a>.</p>
     * <p><h5>To set custom search criteria, use the following parameters:</h5></p>
     * <p><ul>
     *     <li><b>q:</b> Search Criteria using <a href="https://auth0.com/docs/logs/log-search-query-syntax">Query String Syntax</a></li>
     *     <li><b>page:</b> Page index of the results to return. First page is 0.</li>
     *     <li><b>per_page:</b> Number of results per page.</li>
     *     <li><b>sort:</b> Field to use for sorting appended with `:1` for ascending and `:-1` for descending. e.g. `date:-1`</li>
     *     <li><b>fields:</b> Comma-separated list of fields to include or exclude (depending on include_fields) from the result, empty to retrieve all fields.</li>
     *     <li><b>include_fields:</b> Whether specified fields are to be included (true) or excluded (false).</li>
     *     <li><b>include_totals:</b> Return results inside an object that contains the total result count (true) or as a direct array of results (false, default). <b>Deprecated:</b> this field is deprecated and should be removed from use. See <a href="https://auth0.com/docs/product-lifecycle/deprecations-and-migrations/migrate-to-tenant-log-search-v3#pagination">Search Engine V3 Breaking Changes</a></li>
     * </ul></p>
     * <p>For more information on the list of fields that can be used in <code>fields</code> and <code>sort</code>, see <a href="https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields">Searchable Fields</a>.</p>
     * <p>Auth0 <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations">limits the number of logs</a> you can return by search criteria to 100 logs per request. Furthermore, you may paginate only through 1,000 search results. If you exceed this threshold, please redefine your search or use the <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#retrieve-logs-by-checkpoint">get logs by checkpoint method</a>.</p>
     * <p><h5>To search from a checkpoint log ID, use the following parameters:</h5>
     * <ul>
     *     <li><b>from:</b> Log Event ID from which to start retrieving logs. You can limit the number of logs returned using the <code>take</code> parameter. If you use <code>from</code> at the same time as <code>q</code>, <code>from</code> takes precedence and <code>q</code> is ignored.</li>
     *     <li><b>take:</b> Number of entries to retrieve when using the <code>from</code> parameter.</li>
     * </ul></p>
     * <p><strong>Important:</strong> When fetching logs from a checkpoint log ID, any parameter other than <code>from</code> and <code>take</code> will be ignored, and date ordering is not guaranteed.</p>
     */
    public CompletableFuture<ManagementApiHttpResponse<SyncPagingIterable<Log>>> list(RequestOptions requestOptions) {
        return list(ListLogsRequestParameters.builder().build(), requestOptions);
    }

    /**
     * Retrieve log entries that match the specified search criteria (or all log entries if no criteria specified).
     * <p>Set custom search criteria using the <code>q</code> parameter, or search from a specific log ID (<i>&quot;search from checkpoint&quot;</i>).</p>
     * <p>For more information on all possible event types, their respective acronyms, and descriptions, see <a href="https://auth0.com/docs/logs/log-event-type-codes">Log Event Type Codes</a>.</p>
     * <p><h5>To set custom search criteria, use the following parameters:</h5></p>
     * <p><ul>
     *     <li><b>q:</b> Search Criteria using <a href="https://auth0.com/docs/logs/log-search-query-syntax">Query String Syntax</a></li>
     *     <li><b>page:</b> Page index of the results to return. First page is 0.</li>
     *     <li><b>per_page:</b> Number of results per page.</li>
     *     <li><b>sort:</b> Field to use for sorting appended with `:1` for ascending and `:-1` for descending. e.g. `date:-1`</li>
     *     <li><b>fields:</b> Comma-separated list of fields to include or exclude (depending on include_fields) from the result, empty to retrieve all fields.</li>
     *     <li><b>include_fields:</b> Whether specified fields are to be included (true) or excluded (false).</li>
     *     <li><b>include_totals:</b> Return results inside an object that contains the total result count (true) or as a direct array of results (false, default). <b>Deprecated:</b> this field is deprecated and should be removed from use. See <a href="https://auth0.com/docs/product-lifecycle/deprecations-and-migrations/migrate-to-tenant-log-search-v3#pagination">Search Engine V3 Breaking Changes</a></li>
     * </ul></p>
     * <p>For more information on the list of fields that can be used in <code>fields</code> and <code>sort</code>, see <a href="https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields">Searchable Fields</a>.</p>
     * <p>Auth0 <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations">limits the number of logs</a> you can return by search criteria to 100 logs per request. Furthermore, you may paginate only through 1,000 search results. If you exceed this threshold, please redefine your search or use the <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#retrieve-logs-by-checkpoint">get logs by checkpoint method</a>.</p>
     * <p><h5>To search from a checkpoint log ID, use the following parameters:</h5>
     * <ul>
     *     <li><b>from:</b> Log Event ID from which to start retrieving logs. You can limit the number of logs returned using the <code>take</code> parameter. If you use <code>from</code> at the same time as <code>q</code>, <code>from</code> takes precedence and <code>q</code> is ignored.</li>
     *     <li><b>take:</b> Number of entries to retrieve when using the <code>from</code> parameter.</li>
     * </ul></p>
     * <p><strong>Important:</strong> When fetching logs from a checkpoint log ID, any parameter other than <code>from</code> and <code>take</code> will be ignored, and date ordering is not guaranteed.</p>
     */
    public CompletableFuture<ManagementApiHttpResponse<SyncPagingIterable<Log>>> list(
            ListLogsRequestParameters request) {
        return list(request, null);
    }

    /**
     * Retrieve log entries that match the specified search criteria (or all log entries if no criteria specified).
     * <p>Set custom search criteria using the <code>q</code> parameter, or search from a specific log ID (<i>&quot;search from checkpoint&quot;</i>).</p>
     * <p>For more information on all possible event types, their respective acronyms, and descriptions, see <a href="https://auth0.com/docs/logs/log-event-type-codes">Log Event Type Codes</a>.</p>
     * <p><h5>To set custom search criteria, use the following parameters:</h5></p>
     * <p><ul>
     *     <li><b>q:</b> Search Criteria using <a href="https://auth0.com/docs/logs/log-search-query-syntax">Query String Syntax</a></li>
     *     <li><b>page:</b> Page index of the results to return. First page is 0.</li>
     *     <li><b>per_page:</b> Number of results per page.</li>
     *     <li><b>sort:</b> Field to use for sorting appended with `:1` for ascending and `:-1` for descending. e.g. `date:-1`</li>
     *     <li><b>fields:</b> Comma-separated list of fields to include or exclude (depending on include_fields) from the result, empty to retrieve all fields.</li>
     *     <li><b>include_fields:</b> Whether specified fields are to be included (true) or excluded (false).</li>
     *     <li><b>include_totals:</b> Return results inside an object that contains the total result count (true) or as a direct array of results (false, default). <b>Deprecated:</b> this field is deprecated and should be removed from use. See <a href="https://auth0.com/docs/product-lifecycle/deprecations-and-migrations/migrate-to-tenant-log-search-v3#pagination">Search Engine V3 Breaking Changes</a></li>
     * </ul></p>
     * <p>For more information on the list of fields that can be used in <code>fields</code> and <code>sort</code>, see <a href="https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields">Searchable Fields</a>.</p>
     * <p>Auth0 <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations">limits the number of logs</a> you can return by search criteria to 100 logs per request. Furthermore, you may paginate only through 1,000 search results. If you exceed this threshold, please redefine your search or use the <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#retrieve-logs-by-checkpoint">get logs by checkpoint method</a>.</p>
     * <p><h5>To search from a checkpoint log ID, use the following parameters:</h5>
     * <ul>
     *     <li><b>from:</b> Log Event ID from which to start retrieving logs. You can limit the number of logs returned using the <code>take</code> parameter. If you use <code>from</code> at the same time as <code>q</code>, <code>from</code> takes precedence and <code>q</code> is ignored.</li>
     *     <li><b>take:</b> Number of entries to retrieve when using the <code>from</code> parameter.</li>
     * </ul></p>
     * <p><strong>Important:</strong> When fetching logs from a checkpoint log ID, any parameter other than <code>from</code> and <code>take</code> will be ignored, and date ordering is not guaranteed.</p>
     */
    public CompletableFuture<ManagementApiHttpResponse<SyncPagingIterable<Log>>> list(
            ListLogsRequestParameters request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("logs");
        QueryStringMapper.addQueryParameter(httpUrl, "page", request.getPage().orElse(0), false);
        QueryStringMapper.addQueryParameter(
                httpUrl, "per_page", request.getPerPage().orElse(50), false);
        if (!request.getSort().isAbsent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "sort", request.getSort().orElse(null), false);
        }
        if (!request.getFields().isAbsent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "fields", request.getFields().orElse(null), false);
        }
        if (!request.getIncludeFields().isAbsent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "include_fields", request.getIncludeFields().orElse(null), false);
        }
        QueryStringMapper.addQueryParameter(
                httpUrl, "include_totals", request.getIncludeTotals().orElse(true), false);
        if (!request.getSearch().isAbsent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "search", request.getSearch().orElse(null), false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ManagementApiHttpResponse<SyncPagingIterable<Log>>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        ListLogOffsetPaginatedResponseContent parsedResponse = ObjectMappers.JSON_MAPPER.readValue(
                                responseBodyString, ListLogOffsetPaginatedResponseContent.class);
                        int newPageNumber = request.getPage()
                                .map((Integer page) -> page + 1)
                                .orElse(1);
                        ListLogsRequestParameters nextRequest = ListLogsRequestParameters.builder()
                                .from(request)
                                .page(newPageNumber)
                                .build();
                        List<Log> result = parsedResponse.getLogs().orElse(Collections.emptyList());
                        future.complete(new ManagementApiHttpResponse<>(
                                new SyncPagingIterable<Log>(true, result, parsedResponse, () -> {
                                    try {
                                        return list(nextRequest, requestOptions)
                                                .get()
                                                .body();
                                    } catch (InterruptedException | ExecutionException e) {
                                        throw new RuntimeException(e);
                                    }
                                }),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 429:
                                future.completeExceptionally(new TooManyRequestsError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new ManagementApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ManagementException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ManagementException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Retrieve an individual log event.
     */
    public CompletableFuture<ManagementApiHttpResponse<GetLogResponseContent>> get(String id) {
        return get(id, null);
    }

    /**
     * Retrieve an individual log event.
     */
    public CompletableFuture<ManagementApiHttpResponse<GetLogResponseContent>> get(
            String id, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("logs")
                .addPathSegment(id);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<ManagementApiHttpResponse<GetLogResponseContent>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new ManagementApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, GetLogResponseContent.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 429:
                                future.completeExceptionally(new TooManyRequestsError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new ManagementApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new ManagementException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new ManagementException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
