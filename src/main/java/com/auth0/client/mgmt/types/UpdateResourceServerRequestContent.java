/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.auth0.client.mgmt.types;

import com.auth0.client.mgmt.core.NullableNonemptyFilter;
import com.auth0.client.mgmt.core.ObjectMappers;
import com.auth0.client.mgmt.core.OptionalNullable;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.Nullable;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = UpdateResourceServerRequestContent.Builder.class)
public final class UpdateResourceServerRequestContent {
    private final Optional<String> name;

    private final Optional<List<ResourceServerScope>> scopes;

    private final Optional<SigningAlgorithmEnum> signingAlg;

    private final Optional<String> signingSecret;

    private final Optional<Boolean> skipConsentForVerifiableFirstPartyClients;

    private final Optional<Boolean> allowOfflineAccess;

    private final Optional<Integer> tokenLifetime;

    private final Optional<ResourceServerTokenDialectSchemaEnum> tokenDialect;

    private final Optional<Boolean> enforcePolicies;

    private final OptionalNullable<ResourceServerTokenEncryption> tokenEncryption;

    private final OptionalNullable<String> consentPolicy;

    private final Optional<List<Object>> authorizationDetails;

    private final OptionalNullable<ResourceServerProofOfPossession> proofOfPossession;

    private final Map<String, Object> additionalProperties;

    private UpdateResourceServerRequestContent(
            Optional<String> name,
            Optional<List<ResourceServerScope>> scopes,
            Optional<SigningAlgorithmEnum> signingAlg,
            Optional<String> signingSecret,
            Optional<Boolean> skipConsentForVerifiableFirstPartyClients,
            Optional<Boolean> allowOfflineAccess,
            Optional<Integer> tokenLifetime,
            Optional<ResourceServerTokenDialectSchemaEnum> tokenDialect,
            Optional<Boolean> enforcePolicies,
            OptionalNullable<ResourceServerTokenEncryption> tokenEncryption,
            OptionalNullable<String> consentPolicy,
            Optional<List<Object>> authorizationDetails,
            OptionalNullable<ResourceServerProofOfPossession> proofOfPossession,
            Map<String, Object> additionalProperties) {
        this.name = name;
        this.scopes = scopes;
        this.signingAlg = signingAlg;
        this.signingSecret = signingSecret;
        this.skipConsentForVerifiableFirstPartyClients = skipConsentForVerifiableFirstPartyClients;
        this.allowOfflineAccess = allowOfflineAccess;
        this.tokenLifetime = tokenLifetime;
        this.tokenDialect = tokenDialect;
        this.enforcePolicies = enforcePolicies;
        this.tokenEncryption = tokenEncryption;
        this.consentPolicy = consentPolicy;
        this.authorizationDetails = authorizationDetails;
        this.proofOfPossession = proofOfPossession;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Friendly name for this resource server. Can not contain <code>&lt;</code> or <code>&gt;</code> characters.
     */
    @JsonProperty("name")
    public Optional<String> getName() {
        return name;
    }

    /**
     * @return List of permissions (scopes) that this API uses.
     */
    @JsonProperty("scopes")
    public Optional<List<ResourceServerScope>> getScopes() {
        return scopes;
    }

    @JsonProperty("signing_alg")
    public Optional<SigningAlgorithmEnum> getSigningAlg() {
        return signingAlg;
    }

    /**
     * @return Secret used to sign tokens when using symmetric algorithms (HS256).
     */
    @JsonProperty("signing_secret")
    public Optional<String> getSigningSecret() {
        return signingSecret;
    }

    /**
     * @return Whether to skip user consent for applications flagged as first party (true) or not (false).
     */
    @JsonProperty("skip_consent_for_verifiable_first_party_clients")
    public Optional<Boolean> getSkipConsentForVerifiableFirstPartyClients() {
        return skipConsentForVerifiableFirstPartyClients;
    }

    /**
     * @return Whether refresh tokens can be issued for this API (true) or not (false).
     */
    @JsonProperty("allow_offline_access")
    public Optional<Boolean> getAllowOfflineAccess() {
        return allowOfflineAccess;
    }

    /**
     * @return Expiration value (in seconds) for access tokens issued for this API from the token endpoint.
     */
    @JsonProperty("token_lifetime")
    public Optional<Integer> getTokenLifetime() {
        return tokenLifetime;
    }

    @JsonProperty("token_dialect")
    public Optional<ResourceServerTokenDialectSchemaEnum> getTokenDialect() {
        return tokenDialect;
    }

    /**
     * @return Whether authorization policies are enforced (true) or not enforced (false).
     */
    @JsonProperty("enforce_policies")
    public Optional<Boolean> getEnforcePolicies() {
        return enforcePolicies;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("token_encryption")
    public OptionalNullable<ResourceServerTokenEncryption> getTokenEncryption() {
        if (tokenEncryption == null) {
            return OptionalNullable.absent();
        }
        return tokenEncryption;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("consent_policy")
    public OptionalNullable<String> getConsentPolicy() {
        if (consentPolicy == null) {
            return OptionalNullable.absent();
        }
        return consentPolicy;
    }

    @JsonProperty("authorization_details")
    public Optional<List<Object>> getAuthorizationDetails() {
        return authorizationDetails;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("proof_of_possession")
    public OptionalNullable<ResourceServerProofOfPossession> getProofOfPossession() {
        if (proofOfPossession == null) {
            return OptionalNullable.absent();
        }
        return proofOfPossession;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("token_encryption")
    private OptionalNullable<ResourceServerTokenEncryption> _getTokenEncryption() {
        return tokenEncryption;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("consent_policy")
    private OptionalNullable<String> _getConsentPolicy() {
        return consentPolicy;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("proof_of_possession")
    private OptionalNullable<ResourceServerProofOfPossession> _getProofOfPossession() {
        return proofOfPossession;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof UpdateResourceServerRequestContent
                && equalTo((UpdateResourceServerRequestContent) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(UpdateResourceServerRequestContent other) {
        return name.equals(other.name)
                && scopes.equals(other.scopes)
                && signingAlg.equals(other.signingAlg)
                && signingSecret.equals(other.signingSecret)
                && skipConsentForVerifiableFirstPartyClients.equals(other.skipConsentForVerifiableFirstPartyClients)
                && allowOfflineAccess.equals(other.allowOfflineAccess)
                && tokenLifetime.equals(other.tokenLifetime)
                && tokenDialect.equals(other.tokenDialect)
                && enforcePolicies.equals(other.enforcePolicies)
                && tokenEncryption.equals(other.tokenEncryption)
                && consentPolicy.equals(other.consentPolicy)
                && authorizationDetails.equals(other.authorizationDetails)
                && proofOfPossession.equals(other.proofOfPossession);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.name,
                this.scopes,
                this.signingAlg,
                this.signingSecret,
                this.skipConsentForVerifiableFirstPartyClients,
                this.allowOfflineAccess,
                this.tokenLifetime,
                this.tokenDialect,
                this.enforcePolicies,
                this.tokenEncryption,
                this.consentPolicy,
                this.authorizationDetails,
                this.proofOfPossession);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<String> name = Optional.empty();

        private Optional<List<ResourceServerScope>> scopes = Optional.empty();

        private Optional<SigningAlgorithmEnum> signingAlg = Optional.empty();

        private Optional<String> signingSecret = Optional.empty();

        private Optional<Boolean> skipConsentForVerifiableFirstPartyClients = Optional.empty();

        private Optional<Boolean> allowOfflineAccess = Optional.empty();

        private Optional<Integer> tokenLifetime = Optional.empty();

        private Optional<ResourceServerTokenDialectSchemaEnum> tokenDialect = Optional.empty();

        private Optional<Boolean> enforcePolicies = Optional.empty();

        private OptionalNullable<ResourceServerTokenEncryption> tokenEncryption = OptionalNullable.absent();

        private OptionalNullable<String> consentPolicy = OptionalNullable.absent();

        private Optional<List<Object>> authorizationDetails = Optional.empty();

        private OptionalNullable<ResourceServerProofOfPossession> proofOfPossession = OptionalNullable.absent();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(UpdateResourceServerRequestContent other) {
            name(other.getName());
            scopes(other.getScopes());
            signingAlg(other.getSigningAlg());
            signingSecret(other.getSigningSecret());
            skipConsentForVerifiableFirstPartyClients(other.getSkipConsentForVerifiableFirstPartyClients());
            allowOfflineAccess(other.getAllowOfflineAccess());
            tokenLifetime(other.getTokenLifetime());
            tokenDialect(other.getTokenDialect());
            enforcePolicies(other.getEnforcePolicies());
            tokenEncryption(other.getTokenEncryption());
            consentPolicy(other.getConsentPolicy());
            authorizationDetails(other.getAuthorizationDetails());
            proofOfPossession(other.getProofOfPossession());
            return this;
        }

        /**
         * <p>Friendly name for this resource server. Can not contain <code>&lt;</code> or <code>&gt;</code> characters.</p>
         */
        @JsonSetter(value = "name", nulls = Nulls.SKIP)
        public Builder name(Optional<String> name) {
            this.name = name;
            return this;
        }

        public Builder name(String name) {
            this.name = Optional.ofNullable(name);
            return this;
        }

        /**
         * <p>List of permissions (scopes) that this API uses.</p>
         */
        @JsonSetter(value = "scopes", nulls = Nulls.SKIP)
        public Builder scopes(Optional<List<ResourceServerScope>> scopes) {
            this.scopes = scopes;
            return this;
        }

        public Builder scopes(List<ResourceServerScope> scopes) {
            this.scopes = Optional.ofNullable(scopes);
            return this;
        }

        @JsonSetter(value = "signing_alg", nulls = Nulls.SKIP)
        public Builder signingAlg(Optional<SigningAlgorithmEnum> signingAlg) {
            this.signingAlg = signingAlg;
            return this;
        }

        public Builder signingAlg(SigningAlgorithmEnum signingAlg) {
            this.signingAlg = Optional.ofNullable(signingAlg);
            return this;
        }

        /**
         * <p>Secret used to sign tokens when using symmetric algorithms (HS256).</p>
         */
        @JsonSetter(value = "signing_secret", nulls = Nulls.SKIP)
        public Builder signingSecret(Optional<String> signingSecret) {
            this.signingSecret = signingSecret;
            return this;
        }

        public Builder signingSecret(String signingSecret) {
            this.signingSecret = Optional.ofNullable(signingSecret);
            return this;
        }

        /**
         * <p>Whether to skip user consent for applications flagged as first party (true) or not (false).</p>
         */
        @JsonSetter(value = "skip_consent_for_verifiable_first_party_clients", nulls = Nulls.SKIP)
        public Builder skipConsentForVerifiableFirstPartyClients(
                Optional<Boolean> skipConsentForVerifiableFirstPartyClients) {
            this.skipConsentForVerifiableFirstPartyClients = skipConsentForVerifiableFirstPartyClients;
            return this;
        }

        public Builder skipConsentForVerifiableFirstPartyClients(Boolean skipConsentForVerifiableFirstPartyClients) {
            this.skipConsentForVerifiableFirstPartyClients =
                    Optional.ofNullable(skipConsentForVerifiableFirstPartyClients);
            return this;
        }

        /**
         * <p>Whether refresh tokens can be issued for this API (true) or not (false).</p>
         */
        @JsonSetter(value = "allow_offline_access", nulls = Nulls.SKIP)
        public Builder allowOfflineAccess(Optional<Boolean> allowOfflineAccess) {
            this.allowOfflineAccess = allowOfflineAccess;
            return this;
        }

        public Builder allowOfflineAccess(Boolean allowOfflineAccess) {
            this.allowOfflineAccess = Optional.ofNullable(allowOfflineAccess);
            return this;
        }

        /**
         * <p>Expiration value (in seconds) for access tokens issued for this API from the token endpoint.</p>
         */
        @JsonSetter(value = "token_lifetime", nulls = Nulls.SKIP)
        public Builder tokenLifetime(Optional<Integer> tokenLifetime) {
            this.tokenLifetime = tokenLifetime;
            return this;
        }

        public Builder tokenLifetime(Integer tokenLifetime) {
            this.tokenLifetime = Optional.ofNullable(tokenLifetime);
            return this;
        }

        @JsonSetter(value = "token_dialect", nulls = Nulls.SKIP)
        public Builder tokenDialect(Optional<ResourceServerTokenDialectSchemaEnum> tokenDialect) {
            this.tokenDialect = tokenDialect;
            return this;
        }

        public Builder tokenDialect(ResourceServerTokenDialectSchemaEnum tokenDialect) {
            this.tokenDialect = Optional.ofNullable(tokenDialect);
            return this;
        }

        /**
         * <p>Whether authorization policies are enforced (true) or not enforced (false).</p>
         */
        @JsonSetter(value = "enforce_policies", nulls = Nulls.SKIP)
        public Builder enforcePolicies(Optional<Boolean> enforcePolicies) {
            this.enforcePolicies = enforcePolicies;
            return this;
        }

        public Builder enforcePolicies(Boolean enforcePolicies) {
            this.enforcePolicies = Optional.ofNullable(enforcePolicies);
            return this;
        }

        @JsonSetter(value = "token_encryption", nulls = Nulls.SKIP)
        public Builder tokenEncryption(@Nullable OptionalNullable<ResourceServerTokenEncryption> tokenEncryption) {
            this.tokenEncryption = tokenEncryption;
            return this;
        }

        public Builder tokenEncryption(ResourceServerTokenEncryption tokenEncryption) {
            this.tokenEncryption = OptionalNullable.of(tokenEncryption);
            return this;
        }

        public Builder tokenEncryption(Optional<ResourceServerTokenEncryption> tokenEncryption) {
            if (tokenEncryption.isPresent()) {
                this.tokenEncryption = OptionalNullable.of(tokenEncryption.get());
            } else {
                this.tokenEncryption = OptionalNullable.absent();
            }
            return this;
        }

        public Builder tokenEncryption(
                com.auth0.client.mgmt.core.Nullable<ResourceServerTokenEncryption> tokenEncryption) {
            if (tokenEncryption.isNull()) {
                this.tokenEncryption = OptionalNullable.ofNull();
            } else if (tokenEncryption.isEmpty()) {
                this.tokenEncryption = OptionalNullable.absent();
            } else {
                this.tokenEncryption = OptionalNullable.of(tokenEncryption.get());
            }
            return this;
        }

        @JsonSetter(value = "consent_policy", nulls = Nulls.SKIP)
        public Builder consentPolicy(@Nullable OptionalNullable<String> consentPolicy) {
            this.consentPolicy = consentPolicy;
            return this;
        }

        public Builder consentPolicy(String consentPolicy) {
            this.consentPolicy = OptionalNullable.of(consentPolicy);
            return this;
        }

        public Builder consentPolicy(Optional<String> consentPolicy) {
            if (consentPolicy.isPresent()) {
                this.consentPolicy = OptionalNullable.of(consentPolicy.get());
            } else {
                this.consentPolicy = OptionalNullable.absent();
            }
            return this;
        }

        public Builder consentPolicy(com.auth0.client.mgmt.core.Nullable<String> consentPolicy) {
            if (consentPolicy.isNull()) {
                this.consentPolicy = OptionalNullable.ofNull();
            } else if (consentPolicy.isEmpty()) {
                this.consentPolicy = OptionalNullable.absent();
            } else {
                this.consentPolicy = OptionalNullable.of(consentPolicy.get());
            }
            return this;
        }

        @JsonSetter(value = "authorization_details", nulls = Nulls.SKIP)
        public Builder authorizationDetails(Optional<List<Object>> authorizationDetails) {
            this.authorizationDetails = authorizationDetails;
            return this;
        }

        public Builder authorizationDetails(List<Object> authorizationDetails) {
            this.authorizationDetails = Optional.ofNullable(authorizationDetails);
            return this;
        }

        @JsonSetter(value = "proof_of_possession", nulls = Nulls.SKIP)
        public Builder proofOfPossession(
                @Nullable OptionalNullable<ResourceServerProofOfPossession> proofOfPossession) {
            this.proofOfPossession = proofOfPossession;
            return this;
        }

        public Builder proofOfPossession(ResourceServerProofOfPossession proofOfPossession) {
            this.proofOfPossession = OptionalNullable.of(proofOfPossession);
            return this;
        }

        public Builder proofOfPossession(Optional<ResourceServerProofOfPossession> proofOfPossession) {
            if (proofOfPossession.isPresent()) {
                this.proofOfPossession = OptionalNullable.of(proofOfPossession.get());
            } else {
                this.proofOfPossession = OptionalNullable.absent();
            }
            return this;
        }

        public Builder proofOfPossession(
                com.auth0.client.mgmt.core.Nullable<ResourceServerProofOfPossession> proofOfPossession) {
            if (proofOfPossession.isNull()) {
                this.proofOfPossession = OptionalNullable.ofNull();
            } else if (proofOfPossession.isEmpty()) {
                this.proofOfPossession = OptionalNullable.absent();
            } else {
                this.proofOfPossession = OptionalNullable.of(proofOfPossession.get());
            }
            return this;
        }

        public UpdateResourceServerRequestContent build() {
            return new UpdateResourceServerRequestContent(
                    name,
                    scopes,
                    signingAlg,
                    signingSecret,
                    skipConsentForVerifiableFirstPartyClients,
                    allowOfflineAccess,
                    tokenLifetime,
                    tokenDialect,
                    enforcePolicies,
                    tokenEncryption,
                    consentPolicy,
                    authorizationDetails,
                    proofOfPossession,
                    additionalProperties);
        }
    }
}
