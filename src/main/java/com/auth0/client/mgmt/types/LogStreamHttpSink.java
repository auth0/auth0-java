/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.auth0.client.mgmt.types;

import com.auth0.client.mgmt.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = LogStreamHttpSink.Builder.class)
public final class LogStreamHttpSink {
    private final Optional<String> httpAuthorization;

    private final Optional<LogStreamHttpContentFormatEnum> httpContentFormat;

    private final Optional<String> httpContentType;

    private final String httpEndpoint;

    private final Optional<List<HttpCustomHeader>> httpCustomHeaders;

    private final Map<String, Object> additionalProperties;

    private LogStreamHttpSink(
            Optional<String> httpAuthorization,
            Optional<LogStreamHttpContentFormatEnum> httpContentFormat,
            Optional<String> httpContentType,
            String httpEndpoint,
            Optional<List<HttpCustomHeader>> httpCustomHeaders,
            Map<String, Object> additionalProperties) {
        this.httpAuthorization = httpAuthorization;
        this.httpContentFormat = httpContentFormat;
        this.httpContentType = httpContentType;
        this.httpEndpoint = httpEndpoint;
        this.httpCustomHeaders = httpCustomHeaders;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return HTTP Authorization header
     */
    @JsonProperty("httpAuthorization")
    public Optional<String> getHttpAuthorization() {
        return httpAuthorization;
    }

    @JsonProperty("httpContentFormat")
    public Optional<LogStreamHttpContentFormatEnum> getHttpContentFormat() {
        return httpContentFormat;
    }

    /**
     * @return HTTP Content-Type header
     */
    @JsonProperty("httpContentType")
    public Optional<String> getHttpContentType() {
        return httpContentType;
    }

    /**
     * @return HTTP endpoint
     */
    @JsonProperty("httpEndpoint")
    public String getHttpEndpoint() {
        return httpEndpoint;
    }

    /**
     * @return custom HTTP headers
     */
    @JsonProperty("httpCustomHeaders")
    public Optional<List<HttpCustomHeader>> getHttpCustomHeaders() {
        return httpCustomHeaders;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof LogStreamHttpSink && equalTo((LogStreamHttpSink) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(LogStreamHttpSink other) {
        return httpAuthorization.equals(other.httpAuthorization)
                && httpContentFormat.equals(other.httpContentFormat)
                && httpContentType.equals(other.httpContentType)
                && httpEndpoint.equals(other.httpEndpoint)
                && httpCustomHeaders.equals(other.httpCustomHeaders);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.httpAuthorization,
                this.httpContentFormat,
                this.httpContentType,
                this.httpEndpoint,
                this.httpCustomHeaders);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static HttpEndpointStage builder() {
        return new Builder();
    }

    public interface HttpEndpointStage {
        /**
         * <p>HTTP endpoint</p>
         */
        _FinalStage httpEndpoint(@NotNull String httpEndpoint);

        Builder from(LogStreamHttpSink other);
    }

    public interface _FinalStage {
        LogStreamHttpSink build();

        _FinalStage additionalProperty(String key, Object value);

        _FinalStage additionalProperties(Map<String, Object> additionalProperties);

        /**
         * <p>HTTP Authorization header</p>
         */
        _FinalStage httpAuthorization(Optional<String> httpAuthorization);

        _FinalStage httpAuthorization(String httpAuthorization);

        _FinalStage httpContentFormat(Optional<LogStreamHttpContentFormatEnum> httpContentFormat);

        _FinalStage httpContentFormat(LogStreamHttpContentFormatEnum httpContentFormat);

        /**
         * <p>HTTP Content-Type header</p>
         */
        _FinalStage httpContentType(Optional<String> httpContentType);

        _FinalStage httpContentType(String httpContentType);

        /**
         * <p>custom HTTP headers</p>
         */
        _FinalStage httpCustomHeaders(Optional<List<HttpCustomHeader>> httpCustomHeaders);

        _FinalStage httpCustomHeaders(List<HttpCustomHeader> httpCustomHeaders);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements HttpEndpointStage, _FinalStage {
        private String httpEndpoint;

        private Optional<List<HttpCustomHeader>> httpCustomHeaders = Optional.empty();

        private Optional<String> httpContentType = Optional.empty();

        private Optional<LogStreamHttpContentFormatEnum> httpContentFormat = Optional.empty();

        private Optional<String> httpAuthorization = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(LogStreamHttpSink other) {
            httpAuthorization(other.getHttpAuthorization());
            httpContentFormat(other.getHttpContentFormat());
            httpContentType(other.getHttpContentType());
            httpEndpoint(other.getHttpEndpoint());
            httpCustomHeaders(other.getHttpCustomHeaders());
            return this;
        }

        /**
         * <p>HTTP endpoint</p>
         * <p>HTTP endpoint</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("httpEndpoint")
        public _FinalStage httpEndpoint(@NotNull String httpEndpoint) {
            this.httpEndpoint = Objects.requireNonNull(httpEndpoint, "httpEndpoint must not be null");
            return this;
        }

        /**
         * <p>custom HTTP headers</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage httpCustomHeaders(List<HttpCustomHeader> httpCustomHeaders) {
            this.httpCustomHeaders = Optional.ofNullable(httpCustomHeaders);
            return this;
        }

        /**
         * <p>custom HTTP headers</p>
         */
        @java.lang.Override
        @JsonSetter(value = "httpCustomHeaders", nulls = Nulls.SKIP)
        public _FinalStage httpCustomHeaders(Optional<List<HttpCustomHeader>> httpCustomHeaders) {
            this.httpCustomHeaders = httpCustomHeaders;
            return this;
        }

        /**
         * <p>HTTP Content-Type header</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage httpContentType(String httpContentType) {
            this.httpContentType = Optional.ofNullable(httpContentType);
            return this;
        }

        /**
         * <p>HTTP Content-Type header</p>
         */
        @java.lang.Override
        @JsonSetter(value = "httpContentType", nulls = Nulls.SKIP)
        public _FinalStage httpContentType(Optional<String> httpContentType) {
            this.httpContentType = httpContentType;
            return this;
        }

        @java.lang.Override
        public _FinalStage httpContentFormat(LogStreamHttpContentFormatEnum httpContentFormat) {
            this.httpContentFormat = Optional.ofNullable(httpContentFormat);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "httpContentFormat", nulls = Nulls.SKIP)
        public _FinalStage httpContentFormat(Optional<LogStreamHttpContentFormatEnum> httpContentFormat) {
            this.httpContentFormat = httpContentFormat;
            return this;
        }

        /**
         * <p>HTTP Authorization header</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage httpAuthorization(String httpAuthorization) {
            this.httpAuthorization = Optional.ofNullable(httpAuthorization);
            return this;
        }

        /**
         * <p>HTTP Authorization header</p>
         */
        @java.lang.Override
        @JsonSetter(value = "httpAuthorization", nulls = Nulls.SKIP)
        public _FinalStage httpAuthorization(Optional<String> httpAuthorization) {
            this.httpAuthorization = httpAuthorization;
            return this;
        }

        @java.lang.Override
        public LogStreamHttpSink build() {
            return new LogStreamHttpSink(
                    httpAuthorization,
                    httpContentFormat,
                    httpContentType,
                    httpEndpoint,
                    httpCustomHeaders,
                    additionalProperties);
        }

        @java.lang.Override
        public Builder additionalProperty(String key, Object value) {
            this.additionalProperties.put(key, value);
            return this;
        }

        @java.lang.Override
        public Builder additionalProperties(Map<String, Object> additionalProperties) {
            this.additionalProperties.putAll(additionalProperties);
            return this;
        }
    }
}
