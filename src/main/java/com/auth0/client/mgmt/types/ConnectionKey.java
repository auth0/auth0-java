/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.auth0.client.mgmt.types;

import com.auth0.client.mgmt.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ConnectionKey.Builder.class)
public final class ConnectionKey {
    private final String kid;

    private final String cert;

    private final Optional<String> pkcs;

    private final Optional<Boolean> current;

    private final Optional<Boolean> next;

    private final Optional<Boolean> previous;

    private final Optional<String> currentSince;

    private final String fingerprint;

    private final String thumbprint;

    private final Optional<String> algorithm;

    private final Optional<ConnectionKeyUseEnum> keyUse;

    private final Optional<String> subjectDn;

    private final Map<String, Object> additionalProperties;

    private ConnectionKey(
            String kid,
            String cert,
            Optional<String> pkcs,
            Optional<Boolean> current,
            Optional<Boolean> next,
            Optional<Boolean> previous,
            Optional<String> currentSince,
            String fingerprint,
            String thumbprint,
            Optional<String> algorithm,
            Optional<ConnectionKeyUseEnum> keyUse,
            Optional<String> subjectDn,
            Map<String, Object> additionalProperties) {
        this.kid = kid;
        this.cert = cert;
        this.pkcs = pkcs;
        this.current = current;
        this.next = next;
        this.previous = previous;
        this.currentSince = currentSince;
        this.fingerprint = fingerprint;
        this.thumbprint = thumbprint;
        this.algorithm = algorithm;
        this.keyUse = keyUse;
        this.subjectDn = subjectDn;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The key id of the signing key
     */
    @JsonProperty("kid")
    public String getKid() {
        return kid;
    }

    /**
     * @return The public certificate of the signing key
     */
    @JsonProperty("cert")
    public String getCert() {
        return cert;
    }

    /**
     * @return The public certificate of the signing key in pkcs7 format
     */
    @JsonProperty("pkcs")
    public Optional<String> getPkcs() {
        return pkcs;
    }

    /**
     * @return True if the key is the the current key
     */
    @JsonProperty("current")
    public Optional<Boolean> getCurrent() {
        return current;
    }

    /**
     * @return True if the key is the the next key
     */
    @JsonProperty("next")
    public Optional<Boolean> getNext() {
        return next;
    }

    /**
     * @return True if the key is the the previous key
     */
    @JsonProperty("previous")
    public Optional<Boolean> getPrevious() {
        return previous;
    }

    /**
     * @return The date and time when the key became the current key
     */
    @JsonProperty("current_since")
    public Optional<String> getCurrentSince() {
        return currentSince;
    }

    /**
     * @return The cert fingerprint
     */
    @JsonProperty("fingerprint")
    public String getFingerprint() {
        return fingerprint;
    }

    /**
     * @return The cert thumbprint
     */
    @JsonProperty("thumbprint")
    public String getThumbprint() {
        return thumbprint;
    }

    /**
     * @return Signing key algorithm
     */
    @JsonProperty("algorithm")
    public Optional<String> getAlgorithm() {
        return algorithm;
    }

    @JsonProperty("key_use")
    public Optional<ConnectionKeyUseEnum> getKeyUse() {
        return keyUse;
    }

    @JsonProperty("subject_dn")
    public Optional<String> getSubjectDn() {
        return subjectDn;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ConnectionKey && equalTo((ConnectionKey) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ConnectionKey other) {
        return kid.equals(other.kid)
                && cert.equals(other.cert)
                && pkcs.equals(other.pkcs)
                && current.equals(other.current)
                && next.equals(other.next)
                && previous.equals(other.previous)
                && currentSince.equals(other.currentSince)
                && fingerprint.equals(other.fingerprint)
                && thumbprint.equals(other.thumbprint)
                && algorithm.equals(other.algorithm)
                && keyUse.equals(other.keyUse)
                && subjectDn.equals(other.subjectDn);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.kid,
                this.cert,
                this.pkcs,
                this.current,
                this.next,
                this.previous,
                this.currentSince,
                this.fingerprint,
                this.thumbprint,
                this.algorithm,
                this.keyUse,
                this.subjectDn);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static KidStage builder() {
        return new Builder();
    }

    public interface KidStage {
        /**
         * <p>The key id of the signing key</p>
         */
        CertStage kid(@NotNull String kid);

        Builder from(ConnectionKey other);
    }

    public interface CertStage {
        /**
         * <p>The public certificate of the signing key</p>
         */
        FingerprintStage cert(@NotNull String cert);
    }

    public interface FingerprintStage {
        /**
         * <p>The cert fingerprint</p>
         */
        ThumbprintStage fingerprint(@NotNull String fingerprint);
    }

    public interface ThumbprintStage {
        /**
         * <p>The cert thumbprint</p>
         */
        _FinalStage thumbprint(@NotNull String thumbprint);
    }

    public interface _FinalStage {
        ConnectionKey build();

        /**
         * <p>The public certificate of the signing key in pkcs7 format</p>
         */
        _FinalStage pkcs(Optional<String> pkcs);

        _FinalStage pkcs(String pkcs);

        /**
         * <p>True if the key is the the current key</p>
         */
        _FinalStage current(Optional<Boolean> current);

        _FinalStage current(Boolean current);

        /**
         * <p>True if the key is the the next key</p>
         */
        _FinalStage next(Optional<Boolean> next);

        _FinalStage next(Boolean next);

        /**
         * <p>True if the key is the the previous key</p>
         */
        _FinalStage previous(Optional<Boolean> previous);

        _FinalStage previous(Boolean previous);

        /**
         * <p>The date and time when the key became the current key</p>
         */
        _FinalStage currentSince(Optional<String> currentSince);

        _FinalStage currentSince(String currentSince);

        /**
         * <p>Signing key algorithm</p>
         */
        _FinalStage algorithm(Optional<String> algorithm);

        _FinalStage algorithm(String algorithm);

        _FinalStage keyUse(Optional<ConnectionKeyUseEnum> keyUse);

        _FinalStage keyUse(ConnectionKeyUseEnum keyUse);

        _FinalStage subjectDn(Optional<String> subjectDn);

        _FinalStage subjectDn(String subjectDn);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements KidStage, CertStage, FingerprintStage, ThumbprintStage, _FinalStage {
        private String kid;

        private String cert;

        private String fingerprint;

        private String thumbprint;

        private Optional<String> subjectDn = Optional.empty();

        private Optional<ConnectionKeyUseEnum> keyUse = Optional.empty();

        private Optional<String> algorithm = Optional.empty();

        private Optional<String> currentSince = Optional.empty();

        private Optional<Boolean> previous = Optional.empty();

        private Optional<Boolean> next = Optional.empty();

        private Optional<Boolean> current = Optional.empty();

        private Optional<String> pkcs = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(ConnectionKey other) {
            kid(other.getKid());
            cert(other.getCert());
            pkcs(other.getPkcs());
            current(other.getCurrent());
            next(other.getNext());
            previous(other.getPrevious());
            currentSince(other.getCurrentSince());
            fingerprint(other.getFingerprint());
            thumbprint(other.getThumbprint());
            algorithm(other.getAlgorithm());
            keyUse(other.getKeyUse());
            subjectDn(other.getSubjectDn());
            return this;
        }

        /**
         * <p>The key id of the signing key</p>
         * <p>The key id of the signing key</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("kid")
        public CertStage kid(@NotNull String kid) {
            this.kid = Objects.requireNonNull(kid, "kid must not be null");
            return this;
        }

        /**
         * <p>The public certificate of the signing key</p>
         * <p>The public certificate of the signing key</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("cert")
        public FingerprintStage cert(@NotNull String cert) {
            this.cert = Objects.requireNonNull(cert, "cert must not be null");
            return this;
        }

        /**
         * <p>The cert fingerprint</p>
         * <p>The cert fingerprint</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("fingerprint")
        public ThumbprintStage fingerprint(@NotNull String fingerprint) {
            this.fingerprint = Objects.requireNonNull(fingerprint, "fingerprint must not be null");
            return this;
        }

        /**
         * <p>The cert thumbprint</p>
         * <p>The cert thumbprint</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("thumbprint")
        public _FinalStage thumbprint(@NotNull String thumbprint) {
            this.thumbprint = Objects.requireNonNull(thumbprint, "thumbprint must not be null");
            return this;
        }

        @java.lang.Override
        public _FinalStage subjectDn(String subjectDn) {
            this.subjectDn = Optional.ofNullable(subjectDn);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "subject_dn", nulls = Nulls.SKIP)
        public _FinalStage subjectDn(Optional<String> subjectDn) {
            this.subjectDn = subjectDn;
            return this;
        }

        @java.lang.Override
        public _FinalStage keyUse(ConnectionKeyUseEnum keyUse) {
            this.keyUse = Optional.ofNullable(keyUse);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "key_use", nulls = Nulls.SKIP)
        public _FinalStage keyUse(Optional<ConnectionKeyUseEnum> keyUse) {
            this.keyUse = keyUse;
            return this;
        }

        /**
         * <p>Signing key algorithm</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage algorithm(String algorithm) {
            this.algorithm = Optional.ofNullable(algorithm);
            return this;
        }

        /**
         * <p>Signing key algorithm</p>
         */
        @java.lang.Override
        @JsonSetter(value = "algorithm", nulls = Nulls.SKIP)
        public _FinalStage algorithm(Optional<String> algorithm) {
            this.algorithm = algorithm;
            return this;
        }

        /**
         * <p>The date and time when the key became the current key</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage currentSince(String currentSince) {
            this.currentSince = Optional.ofNullable(currentSince);
            return this;
        }

        /**
         * <p>The date and time when the key became the current key</p>
         */
        @java.lang.Override
        @JsonSetter(value = "current_since", nulls = Nulls.SKIP)
        public _FinalStage currentSince(Optional<String> currentSince) {
            this.currentSince = currentSince;
            return this;
        }

        /**
         * <p>True if the key is the the previous key</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage previous(Boolean previous) {
            this.previous = Optional.ofNullable(previous);
            return this;
        }

        /**
         * <p>True if the key is the the previous key</p>
         */
        @java.lang.Override
        @JsonSetter(value = "previous", nulls = Nulls.SKIP)
        public _FinalStage previous(Optional<Boolean> previous) {
            this.previous = previous;
            return this;
        }

        /**
         * <p>True if the key is the the next key</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage next(Boolean next) {
            this.next = Optional.ofNullable(next);
            return this;
        }

        /**
         * <p>True if the key is the the next key</p>
         */
        @java.lang.Override
        @JsonSetter(value = "next", nulls = Nulls.SKIP)
        public _FinalStage next(Optional<Boolean> next) {
            this.next = next;
            return this;
        }

        /**
         * <p>True if the key is the the current key</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage current(Boolean current) {
            this.current = Optional.ofNullable(current);
            return this;
        }

        /**
         * <p>True if the key is the the current key</p>
         */
        @java.lang.Override
        @JsonSetter(value = "current", nulls = Nulls.SKIP)
        public _FinalStage current(Optional<Boolean> current) {
            this.current = current;
            return this;
        }

        /**
         * <p>The public certificate of the signing key in pkcs7 format</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage pkcs(String pkcs) {
            this.pkcs = Optional.ofNullable(pkcs);
            return this;
        }

        /**
         * <p>The public certificate of the signing key in pkcs7 format</p>
         */
        @java.lang.Override
        @JsonSetter(value = "pkcs", nulls = Nulls.SKIP)
        public _FinalStage pkcs(Optional<String> pkcs) {
            this.pkcs = pkcs;
            return this;
        }

        @java.lang.Override
        public ConnectionKey build() {
            return new ConnectionKey(
                    kid,
                    cert,
                    pkcs,
                    current,
                    next,
                    previous,
                    currentSince,
                    fingerprint,
                    thumbprint,
                    algorithm,
                    keyUse,
                    subjectDn,
                    additionalProperties);
        }
    }
}
