/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.auth0.client.mgmt.types;

import com.auth0.client.mgmt.core.NullableNonemptyFilter;
import com.auth0.client.mgmt.core.ObjectMappers;
import com.auth0.client.mgmt.core.OptionalNullable;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.Nullable;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = UpdateResourceServerResponseContent.Builder.class)
public final class UpdateResourceServerResponseContent {
    private final Optional<String> id;

    private final Optional<String> name;

    private final Optional<Boolean> isSystem;

    private final Optional<String> identifier;

    private final Optional<List<ResourceServerScope>> scopes;

    private final Optional<SigningAlgorithmEnum> signingAlg;

    private final Optional<String> signingSecret;

    private final Optional<Boolean> allowOfflineAccess;

    private final Optional<Boolean> skipConsentForVerifiableFirstPartyClients;

    private final Optional<Integer> tokenLifetime;

    private final Optional<Integer> tokenLifetimeForWeb;

    private final Optional<Boolean> enforcePolicies;

    private final Optional<ResourceServerTokenDialectResponseEnum> tokenDialect;

    private final OptionalNullable<ResourceServerTokenEncryption> tokenEncryption;

    private final OptionalNullable<String> consentPolicy;

    private final Optional<List<Object>> authorizationDetails;

    private final OptionalNullable<ResourceServerProofOfPossession> proofOfPossession;

    private final Optional<ResourceServerSubjectTypeAuthorization> subjectTypeAuthorization;

    private final Optional<String> clientId;

    private final Map<String, Object> additionalProperties;

    private UpdateResourceServerResponseContent(
            Optional<String> id,
            Optional<String> name,
            Optional<Boolean> isSystem,
            Optional<String> identifier,
            Optional<List<ResourceServerScope>> scopes,
            Optional<SigningAlgorithmEnum> signingAlg,
            Optional<String> signingSecret,
            Optional<Boolean> allowOfflineAccess,
            Optional<Boolean> skipConsentForVerifiableFirstPartyClients,
            Optional<Integer> tokenLifetime,
            Optional<Integer> tokenLifetimeForWeb,
            Optional<Boolean> enforcePolicies,
            Optional<ResourceServerTokenDialectResponseEnum> tokenDialect,
            OptionalNullable<ResourceServerTokenEncryption> tokenEncryption,
            OptionalNullable<String> consentPolicy,
            Optional<List<Object>> authorizationDetails,
            OptionalNullable<ResourceServerProofOfPossession> proofOfPossession,
            Optional<ResourceServerSubjectTypeAuthorization> subjectTypeAuthorization,
            Optional<String> clientId,
            Map<String, Object> additionalProperties) {
        this.id = id;
        this.name = name;
        this.isSystem = isSystem;
        this.identifier = identifier;
        this.scopes = scopes;
        this.signingAlg = signingAlg;
        this.signingSecret = signingSecret;
        this.allowOfflineAccess = allowOfflineAccess;
        this.skipConsentForVerifiableFirstPartyClients = skipConsentForVerifiableFirstPartyClients;
        this.tokenLifetime = tokenLifetime;
        this.tokenLifetimeForWeb = tokenLifetimeForWeb;
        this.enforcePolicies = enforcePolicies;
        this.tokenDialect = tokenDialect;
        this.tokenEncryption = tokenEncryption;
        this.consentPolicy = consentPolicy;
        this.authorizationDetails = authorizationDetails;
        this.proofOfPossession = proofOfPossession;
        this.subjectTypeAuthorization = subjectTypeAuthorization;
        this.clientId = clientId;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return ID of the API (resource server).
     */
    @JsonProperty("id")
    public Optional<String> getId() {
        return id;
    }

    /**
     * @return Friendly name for this resource server. Can not contain <code>&lt;</code> or <code>&gt;</code> characters.
     */
    @JsonProperty("name")
    public Optional<String> getName() {
        return name;
    }

    /**
     * @return Whether this is an Auth0 system API (true) or a custom API (false).
     */
    @JsonProperty("is_system")
    public Optional<Boolean> getIsSystem() {
        return isSystem;
    }

    /**
     * @return Unique identifier for the API used as the audience parameter on authorization calls. Can not be changed once set.
     */
    @JsonProperty("identifier")
    public Optional<String> getIdentifier() {
        return identifier;
    }

    /**
     * @return List of permissions (scopes) that this API uses.
     */
    @JsonProperty("scopes")
    public Optional<List<ResourceServerScope>> getScopes() {
        return scopes;
    }

    @JsonProperty("signing_alg")
    public Optional<SigningAlgorithmEnum> getSigningAlg() {
        return signingAlg;
    }

    /**
     * @return Secret used to sign tokens when using symmetric algorithms (HS256).
     */
    @JsonProperty("signing_secret")
    public Optional<String> getSigningSecret() {
        return signingSecret;
    }

    /**
     * @return Whether refresh tokens can be issued for this API (true) or not (false).
     */
    @JsonProperty("allow_offline_access")
    public Optional<Boolean> getAllowOfflineAccess() {
        return allowOfflineAccess;
    }

    /**
     * @return Whether to skip user consent for applications flagged as first party (true) or not (false).
     */
    @JsonProperty("skip_consent_for_verifiable_first_party_clients")
    public Optional<Boolean> getSkipConsentForVerifiableFirstPartyClients() {
        return skipConsentForVerifiableFirstPartyClients;
    }

    /**
     * @return Expiration value (in seconds) for access tokens issued for this API from the token endpoint.
     */
    @JsonProperty("token_lifetime")
    public Optional<Integer> getTokenLifetime() {
        return tokenLifetime;
    }

    /**
     * @return Expiration value (in seconds) for access tokens issued for this API via Implicit or Hybrid Flows. Cannot be greater than the <code>token_lifetime</code> value.
     */
    @JsonProperty("token_lifetime_for_web")
    public Optional<Integer> getTokenLifetimeForWeb() {
        return tokenLifetimeForWeb;
    }

    /**
     * @return Whether authorization polices are enforced (true) or unenforced (false).
     */
    @JsonProperty("enforce_policies")
    public Optional<Boolean> getEnforcePolicies() {
        return enforcePolicies;
    }

    @JsonProperty("token_dialect")
    public Optional<ResourceServerTokenDialectResponseEnum> getTokenDialect() {
        return tokenDialect;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("token_encryption")
    public OptionalNullable<ResourceServerTokenEncryption> getTokenEncryption() {
        if (tokenEncryption == null) {
            return OptionalNullable.absent();
        }
        return tokenEncryption;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("consent_policy")
    public OptionalNullable<String> getConsentPolicy() {
        if (consentPolicy == null) {
            return OptionalNullable.absent();
        }
        return consentPolicy;
    }

    @JsonProperty("authorization_details")
    public Optional<List<Object>> getAuthorizationDetails() {
        return authorizationDetails;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("proof_of_possession")
    public OptionalNullable<ResourceServerProofOfPossession> getProofOfPossession() {
        if (proofOfPossession == null) {
            return OptionalNullable.absent();
        }
        return proofOfPossession;
    }

    @JsonProperty("subject_type_authorization")
    public Optional<ResourceServerSubjectTypeAuthorization> getSubjectTypeAuthorization() {
        return subjectTypeAuthorization;
    }

    /**
     * @return The client ID of the client that this resource server is linked to
     */
    @JsonProperty("client_id")
    public Optional<String> getClientId() {
        return clientId;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("token_encryption")
    private OptionalNullable<ResourceServerTokenEncryption> _getTokenEncryption() {
        return tokenEncryption;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("consent_policy")
    private OptionalNullable<String> _getConsentPolicy() {
        return consentPolicy;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("proof_of_possession")
    private OptionalNullable<ResourceServerProofOfPossession> _getProofOfPossession() {
        return proofOfPossession;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof UpdateResourceServerResponseContent
                && equalTo((UpdateResourceServerResponseContent) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(UpdateResourceServerResponseContent other) {
        return id.equals(other.id)
                && name.equals(other.name)
                && isSystem.equals(other.isSystem)
                && identifier.equals(other.identifier)
                && scopes.equals(other.scopes)
                && signingAlg.equals(other.signingAlg)
                && signingSecret.equals(other.signingSecret)
                && allowOfflineAccess.equals(other.allowOfflineAccess)
                && skipConsentForVerifiableFirstPartyClients.equals(other.skipConsentForVerifiableFirstPartyClients)
                && tokenLifetime.equals(other.tokenLifetime)
                && tokenLifetimeForWeb.equals(other.tokenLifetimeForWeb)
                && enforcePolicies.equals(other.enforcePolicies)
                && tokenDialect.equals(other.tokenDialect)
                && tokenEncryption.equals(other.tokenEncryption)
                && consentPolicy.equals(other.consentPolicy)
                && authorizationDetails.equals(other.authorizationDetails)
                && proofOfPossession.equals(other.proofOfPossession)
                && subjectTypeAuthorization.equals(other.subjectTypeAuthorization)
                && clientId.equals(other.clientId);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.id,
                this.name,
                this.isSystem,
                this.identifier,
                this.scopes,
                this.signingAlg,
                this.signingSecret,
                this.allowOfflineAccess,
                this.skipConsentForVerifiableFirstPartyClients,
                this.tokenLifetime,
                this.tokenLifetimeForWeb,
                this.enforcePolicies,
                this.tokenDialect,
                this.tokenEncryption,
                this.consentPolicy,
                this.authorizationDetails,
                this.proofOfPossession,
                this.subjectTypeAuthorization,
                this.clientId);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<String> id = Optional.empty();

        private Optional<String> name = Optional.empty();

        private Optional<Boolean> isSystem = Optional.empty();

        private Optional<String> identifier = Optional.empty();

        private Optional<List<ResourceServerScope>> scopes = Optional.empty();

        private Optional<SigningAlgorithmEnum> signingAlg = Optional.empty();

        private Optional<String> signingSecret = Optional.empty();

        private Optional<Boolean> allowOfflineAccess = Optional.empty();

        private Optional<Boolean> skipConsentForVerifiableFirstPartyClients = Optional.empty();

        private Optional<Integer> tokenLifetime = Optional.empty();

        private Optional<Integer> tokenLifetimeForWeb = Optional.empty();

        private Optional<Boolean> enforcePolicies = Optional.empty();

        private Optional<ResourceServerTokenDialectResponseEnum> tokenDialect = Optional.empty();

        private OptionalNullable<ResourceServerTokenEncryption> tokenEncryption = OptionalNullable.absent();

        private OptionalNullable<String> consentPolicy = OptionalNullable.absent();

        private Optional<List<Object>> authorizationDetails = Optional.empty();

        private OptionalNullable<ResourceServerProofOfPossession> proofOfPossession = OptionalNullable.absent();

        private Optional<ResourceServerSubjectTypeAuthorization> subjectTypeAuthorization = Optional.empty();

        private Optional<String> clientId = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(UpdateResourceServerResponseContent other) {
            id(other.getId());
            name(other.getName());
            isSystem(other.getIsSystem());
            identifier(other.getIdentifier());
            scopes(other.getScopes());
            signingAlg(other.getSigningAlg());
            signingSecret(other.getSigningSecret());
            allowOfflineAccess(other.getAllowOfflineAccess());
            skipConsentForVerifiableFirstPartyClients(other.getSkipConsentForVerifiableFirstPartyClients());
            tokenLifetime(other.getTokenLifetime());
            tokenLifetimeForWeb(other.getTokenLifetimeForWeb());
            enforcePolicies(other.getEnforcePolicies());
            tokenDialect(other.getTokenDialect());
            tokenEncryption(other.getTokenEncryption());
            consentPolicy(other.getConsentPolicy());
            authorizationDetails(other.getAuthorizationDetails());
            proofOfPossession(other.getProofOfPossession());
            subjectTypeAuthorization(other.getSubjectTypeAuthorization());
            clientId(other.getClientId());
            return this;
        }

        /**
         * <p>ID of the API (resource server).</p>
         */
        @JsonSetter(value = "id", nulls = Nulls.SKIP)
        public Builder id(Optional<String> id) {
            this.id = id;
            return this;
        }

        public Builder id(String id) {
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * <p>Friendly name for this resource server. Can not contain <code>&lt;</code> or <code>&gt;</code> characters.</p>
         */
        @JsonSetter(value = "name", nulls = Nulls.SKIP)
        public Builder name(Optional<String> name) {
            this.name = name;
            return this;
        }

        public Builder name(String name) {
            this.name = Optional.ofNullable(name);
            return this;
        }

        /**
         * <p>Whether this is an Auth0 system API (true) or a custom API (false).</p>
         */
        @JsonSetter(value = "is_system", nulls = Nulls.SKIP)
        public Builder isSystem(Optional<Boolean> isSystem) {
            this.isSystem = isSystem;
            return this;
        }

        public Builder isSystem(Boolean isSystem) {
            this.isSystem = Optional.ofNullable(isSystem);
            return this;
        }

        /**
         * <p>Unique identifier for the API used as the audience parameter on authorization calls. Can not be changed once set.</p>
         */
        @JsonSetter(value = "identifier", nulls = Nulls.SKIP)
        public Builder identifier(Optional<String> identifier) {
            this.identifier = identifier;
            return this;
        }

        public Builder identifier(String identifier) {
            this.identifier = Optional.ofNullable(identifier);
            return this;
        }

        /**
         * <p>List of permissions (scopes) that this API uses.</p>
         */
        @JsonSetter(value = "scopes", nulls = Nulls.SKIP)
        public Builder scopes(Optional<List<ResourceServerScope>> scopes) {
            this.scopes = scopes;
            return this;
        }

        public Builder scopes(List<ResourceServerScope> scopes) {
            this.scopes = Optional.ofNullable(scopes);
            return this;
        }

        @JsonSetter(value = "signing_alg", nulls = Nulls.SKIP)
        public Builder signingAlg(Optional<SigningAlgorithmEnum> signingAlg) {
            this.signingAlg = signingAlg;
            return this;
        }

        public Builder signingAlg(SigningAlgorithmEnum signingAlg) {
            this.signingAlg = Optional.ofNullable(signingAlg);
            return this;
        }

        /**
         * <p>Secret used to sign tokens when using symmetric algorithms (HS256).</p>
         */
        @JsonSetter(value = "signing_secret", nulls = Nulls.SKIP)
        public Builder signingSecret(Optional<String> signingSecret) {
            this.signingSecret = signingSecret;
            return this;
        }

        public Builder signingSecret(String signingSecret) {
            this.signingSecret = Optional.ofNullable(signingSecret);
            return this;
        }

        /**
         * <p>Whether refresh tokens can be issued for this API (true) or not (false).</p>
         */
        @JsonSetter(value = "allow_offline_access", nulls = Nulls.SKIP)
        public Builder allowOfflineAccess(Optional<Boolean> allowOfflineAccess) {
            this.allowOfflineAccess = allowOfflineAccess;
            return this;
        }

        public Builder allowOfflineAccess(Boolean allowOfflineAccess) {
            this.allowOfflineAccess = Optional.ofNullable(allowOfflineAccess);
            return this;
        }

        /**
         * <p>Whether to skip user consent for applications flagged as first party (true) or not (false).</p>
         */
        @JsonSetter(value = "skip_consent_for_verifiable_first_party_clients", nulls = Nulls.SKIP)
        public Builder skipConsentForVerifiableFirstPartyClients(
                Optional<Boolean> skipConsentForVerifiableFirstPartyClients) {
            this.skipConsentForVerifiableFirstPartyClients = skipConsentForVerifiableFirstPartyClients;
            return this;
        }

        public Builder skipConsentForVerifiableFirstPartyClients(Boolean skipConsentForVerifiableFirstPartyClients) {
            this.skipConsentForVerifiableFirstPartyClients =
                    Optional.ofNullable(skipConsentForVerifiableFirstPartyClients);
            return this;
        }

        /**
         * <p>Expiration value (in seconds) for access tokens issued for this API from the token endpoint.</p>
         */
        @JsonSetter(value = "token_lifetime", nulls = Nulls.SKIP)
        public Builder tokenLifetime(Optional<Integer> tokenLifetime) {
            this.tokenLifetime = tokenLifetime;
            return this;
        }

        public Builder tokenLifetime(Integer tokenLifetime) {
            this.tokenLifetime = Optional.ofNullable(tokenLifetime);
            return this;
        }

        /**
         * <p>Expiration value (in seconds) for access tokens issued for this API via Implicit or Hybrid Flows. Cannot be greater than the <code>token_lifetime</code> value.</p>
         */
        @JsonSetter(value = "token_lifetime_for_web", nulls = Nulls.SKIP)
        public Builder tokenLifetimeForWeb(Optional<Integer> tokenLifetimeForWeb) {
            this.tokenLifetimeForWeb = tokenLifetimeForWeb;
            return this;
        }

        public Builder tokenLifetimeForWeb(Integer tokenLifetimeForWeb) {
            this.tokenLifetimeForWeb = Optional.ofNullable(tokenLifetimeForWeb);
            return this;
        }

        /**
         * <p>Whether authorization polices are enforced (true) or unenforced (false).</p>
         */
        @JsonSetter(value = "enforce_policies", nulls = Nulls.SKIP)
        public Builder enforcePolicies(Optional<Boolean> enforcePolicies) {
            this.enforcePolicies = enforcePolicies;
            return this;
        }

        public Builder enforcePolicies(Boolean enforcePolicies) {
            this.enforcePolicies = Optional.ofNullable(enforcePolicies);
            return this;
        }

        @JsonSetter(value = "token_dialect", nulls = Nulls.SKIP)
        public Builder tokenDialect(Optional<ResourceServerTokenDialectResponseEnum> tokenDialect) {
            this.tokenDialect = tokenDialect;
            return this;
        }

        public Builder tokenDialect(ResourceServerTokenDialectResponseEnum tokenDialect) {
            this.tokenDialect = Optional.ofNullable(tokenDialect);
            return this;
        }

        @JsonSetter(value = "token_encryption", nulls = Nulls.SKIP)
        public Builder tokenEncryption(@Nullable OptionalNullable<ResourceServerTokenEncryption> tokenEncryption) {
            this.tokenEncryption = tokenEncryption;
            return this;
        }

        public Builder tokenEncryption(ResourceServerTokenEncryption tokenEncryption) {
            this.tokenEncryption = OptionalNullable.of(tokenEncryption);
            return this;
        }

        public Builder tokenEncryption(Optional<ResourceServerTokenEncryption> tokenEncryption) {
            if (tokenEncryption.isPresent()) {
                this.tokenEncryption = OptionalNullable.of(tokenEncryption.get());
            } else {
                this.tokenEncryption = OptionalNullable.absent();
            }
            return this;
        }

        public Builder tokenEncryption(
                com.auth0.client.mgmt.core.Nullable<ResourceServerTokenEncryption> tokenEncryption) {
            if (tokenEncryption.isNull()) {
                this.tokenEncryption = OptionalNullable.ofNull();
            } else if (tokenEncryption.isEmpty()) {
                this.tokenEncryption = OptionalNullable.absent();
            } else {
                this.tokenEncryption = OptionalNullable.of(tokenEncryption.get());
            }
            return this;
        }

        @JsonSetter(value = "consent_policy", nulls = Nulls.SKIP)
        public Builder consentPolicy(@Nullable OptionalNullable<String> consentPolicy) {
            this.consentPolicy = consentPolicy;
            return this;
        }

        public Builder consentPolicy(String consentPolicy) {
            this.consentPolicy = OptionalNullable.of(consentPolicy);
            return this;
        }

        public Builder consentPolicy(Optional<String> consentPolicy) {
            if (consentPolicy.isPresent()) {
                this.consentPolicy = OptionalNullable.of(consentPolicy.get());
            } else {
                this.consentPolicy = OptionalNullable.absent();
            }
            return this;
        }

        public Builder consentPolicy(com.auth0.client.mgmt.core.Nullable<String> consentPolicy) {
            if (consentPolicy.isNull()) {
                this.consentPolicy = OptionalNullable.ofNull();
            } else if (consentPolicy.isEmpty()) {
                this.consentPolicy = OptionalNullable.absent();
            } else {
                this.consentPolicy = OptionalNullable.of(consentPolicy.get());
            }
            return this;
        }

        @JsonSetter(value = "authorization_details", nulls = Nulls.SKIP)
        public Builder authorizationDetails(Optional<List<Object>> authorizationDetails) {
            this.authorizationDetails = authorizationDetails;
            return this;
        }

        public Builder authorizationDetails(List<Object> authorizationDetails) {
            this.authorizationDetails = Optional.ofNullable(authorizationDetails);
            return this;
        }

        @JsonSetter(value = "proof_of_possession", nulls = Nulls.SKIP)
        public Builder proofOfPossession(
                @Nullable OptionalNullable<ResourceServerProofOfPossession> proofOfPossession) {
            this.proofOfPossession = proofOfPossession;
            return this;
        }

        public Builder proofOfPossession(ResourceServerProofOfPossession proofOfPossession) {
            this.proofOfPossession = OptionalNullable.of(proofOfPossession);
            return this;
        }

        public Builder proofOfPossession(Optional<ResourceServerProofOfPossession> proofOfPossession) {
            if (proofOfPossession.isPresent()) {
                this.proofOfPossession = OptionalNullable.of(proofOfPossession.get());
            } else {
                this.proofOfPossession = OptionalNullable.absent();
            }
            return this;
        }

        public Builder proofOfPossession(
                com.auth0.client.mgmt.core.Nullable<ResourceServerProofOfPossession> proofOfPossession) {
            if (proofOfPossession.isNull()) {
                this.proofOfPossession = OptionalNullable.ofNull();
            } else if (proofOfPossession.isEmpty()) {
                this.proofOfPossession = OptionalNullable.absent();
            } else {
                this.proofOfPossession = OptionalNullable.of(proofOfPossession.get());
            }
            return this;
        }

        @JsonSetter(value = "subject_type_authorization", nulls = Nulls.SKIP)
        public Builder subjectTypeAuthorization(
                Optional<ResourceServerSubjectTypeAuthorization> subjectTypeAuthorization) {
            this.subjectTypeAuthorization = subjectTypeAuthorization;
            return this;
        }

        public Builder subjectTypeAuthorization(ResourceServerSubjectTypeAuthorization subjectTypeAuthorization) {
            this.subjectTypeAuthorization = Optional.ofNullable(subjectTypeAuthorization);
            return this;
        }

        /**
         * <p>The client ID of the client that this resource server is linked to</p>
         */
        @JsonSetter(value = "client_id", nulls = Nulls.SKIP)
        public Builder clientId(Optional<String> clientId) {
            this.clientId = clientId;
            return this;
        }

        public Builder clientId(String clientId) {
            this.clientId = Optional.ofNullable(clientId);
            return this;
        }

        public UpdateResourceServerResponseContent build() {
            return new UpdateResourceServerResponseContent(
                    id,
                    name,
                    isSystem,
                    identifier,
                    scopes,
                    signingAlg,
                    signingSecret,
                    allowOfflineAccess,
                    skipConsentForVerifiableFirstPartyClients,
                    tokenLifetime,
                    tokenLifetimeForWeb,
                    enforcePolicies,
                    tokenDialect,
                    tokenEncryption,
                    consentPolicy,
                    authorizationDetails,
                    proofOfPossession,
                    subjectTypeAuthorization,
                    clientId,
                    additionalProperties);
        }
    }
}
