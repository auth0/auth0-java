/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.auth0.client.mgmt;

import com.auth0.client.mgmt.actions.ExecutionsClient;
import com.auth0.client.mgmt.actions.ModulesClient;
import com.auth0.client.mgmt.actions.TriggersClient;
import com.auth0.client.mgmt.actions.VersionsClient;
import com.auth0.client.mgmt.core.ClientOptions;
import com.auth0.client.mgmt.core.RequestOptions;
import com.auth0.client.mgmt.core.Suppliers;
import com.auth0.client.mgmt.core.SyncPagingIterable;
import com.auth0.client.mgmt.types.Action;
import com.auth0.client.mgmt.types.CreateActionRequestContent;
import com.auth0.client.mgmt.types.CreateActionResponseContent;
import com.auth0.client.mgmt.types.DeleteActionRequestParameters;
import com.auth0.client.mgmt.types.DeployActionResponseContent;
import com.auth0.client.mgmt.types.GetActionResponseContent;
import com.auth0.client.mgmt.types.ListActionsRequestParameters;
import com.auth0.client.mgmt.types.TestActionRequestContent;
import com.auth0.client.mgmt.types.TestActionResponseContent;
import com.auth0.client.mgmt.types.UpdateActionRequestContent;
import com.auth0.client.mgmt.types.UpdateActionResponseContent;
import java.util.function.Supplier;

public class ActionsClient {
    protected final ClientOptions clientOptions;

    private final RawActionsClient rawClient;

    protected final Supplier<VersionsClient> versionsClient;

    protected final Supplier<ExecutionsClient> executionsClient;

    protected final Supplier<ModulesClient> modulesClient;

    protected final Supplier<TriggersClient> triggersClient;

    public ActionsClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
        this.rawClient = new RawActionsClient(clientOptions);
        this.versionsClient = Suppliers.memoize(() -> new VersionsClient(clientOptions));
        this.executionsClient = Suppliers.memoize(() -> new ExecutionsClient(clientOptions));
        this.modulesClient = Suppliers.memoize(() -> new ModulesClient(clientOptions));
        this.triggersClient = Suppliers.memoize(() -> new TriggersClient(clientOptions));
    }

    /**
     * Get responses with HTTP metadata like headers
     */
    public RawActionsClient withRawResponse() {
        return this.rawClient;
    }

    /**
     * Retrieve all actions.
     */
    public SyncPagingIterable<Action> list() {
        return this.rawClient.list().body();
    }

    /**
     * Retrieve all actions.
     */
    public SyncPagingIterable<Action> list(ListActionsRequestParameters request) {
        return this.rawClient.list(request).body();
    }

    /**
     * Retrieve all actions.
     */
    public SyncPagingIterable<Action> list(ListActionsRequestParameters request, RequestOptions requestOptions) {
        return this.rawClient.list(request, requestOptions).body();
    }

    /**
     * Create an action. Once an action is created, it must be deployed, and then bound to a trigger before it will be executed as part of a flow.
     */
    public CreateActionResponseContent create(CreateActionRequestContent request) {
        return this.rawClient.create(request).body();
    }

    /**
     * Create an action. Once an action is created, it must be deployed, and then bound to a trigger before it will be executed as part of a flow.
     */
    public CreateActionResponseContent create(CreateActionRequestContent request, RequestOptions requestOptions) {
        return this.rawClient.create(request, requestOptions).body();
    }

    /**
     * Retrieve an action by its ID.
     */
    public GetActionResponseContent get(String id) {
        return this.rawClient.get(id).body();
    }

    /**
     * Retrieve an action by its ID.
     */
    public GetActionResponseContent get(String id, RequestOptions requestOptions) {
        return this.rawClient.get(id, requestOptions).body();
    }

    /**
     * Deletes an action and all of its associated versions. An action must be unbound from all triggers before it can be deleted.
     */
    public void delete(String id) {
        this.rawClient.delete(id).body();
    }

    /**
     * Deletes an action and all of its associated versions. An action must be unbound from all triggers before it can be deleted.
     */
    public void delete(String id, DeleteActionRequestParameters request) {
        this.rawClient.delete(id, request).body();
    }

    /**
     * Deletes an action and all of its associated versions. An action must be unbound from all triggers before it can be deleted.
     */
    public void delete(String id, DeleteActionRequestParameters request, RequestOptions requestOptions) {
        this.rawClient.delete(id, request, requestOptions).body();
    }

    /**
     * Update an existing action. If this action is currently bound to a trigger, updating it will &lt;strong&gt;not&lt;/strong&gt; affect any user flows until the action is deployed.
     */
    public UpdateActionResponseContent update(String id) {
        return this.rawClient.update(id).body();
    }

    /**
     * Update an existing action. If this action is currently bound to a trigger, updating it will &lt;strong&gt;not&lt;/strong&gt; affect any user flows until the action is deployed.
     */
    public UpdateActionResponseContent update(String id, UpdateActionRequestContent request) {
        return this.rawClient.update(id, request).body();
    }

    /**
     * Update an existing action. If this action is currently bound to a trigger, updating it will &lt;strong&gt;not&lt;/strong&gt; affect any user flows until the action is deployed.
     */
    public UpdateActionResponseContent update(
            String id, UpdateActionRequestContent request, RequestOptions requestOptions) {
        return this.rawClient.update(id, request, requestOptions).body();
    }

    /**
     * Deploy an action. Deploying an action will create a new immutable version of the action. If the action is currently bound to a trigger, then the system will begin executing the newly deployed version of the action immediately. Otherwise, the action will only be executed as a part of a flow once it is bound to that flow.
     */
    public DeployActionResponseContent deploy(String id) {
        return this.rawClient.deploy(id).body();
    }

    /**
     * Deploy an action. Deploying an action will create a new immutable version of the action. If the action is currently bound to a trigger, then the system will begin executing the newly deployed version of the action immediately. Otherwise, the action will only be executed as a part of a flow once it is bound to that flow.
     */
    public DeployActionResponseContent deploy(String id, RequestOptions requestOptions) {
        return this.rawClient.deploy(id, requestOptions).body();
    }

    /**
     * Test an action. After updating an action, it can be tested prior to being deployed to ensure it behaves as expected.
     */
    public TestActionResponseContent test(String id, TestActionRequestContent request) {
        return this.rawClient.test(id, request).body();
    }

    /**
     * Test an action. After updating an action, it can be tested prior to being deployed to ensure it behaves as expected.
     */
    public TestActionResponseContent test(String id, TestActionRequestContent request, RequestOptions requestOptions) {
        return this.rawClient.test(id, request, requestOptions).body();
    }

    public VersionsClient versions() {
        return this.versionsClient.get();
    }

    public ExecutionsClient executions() {
        return this.executionsClient.get();
    }

    public ModulesClient modules() {
        return this.modulesClient.get();
    }

    public TriggersClient triggers() {
        return this.triggersClient.get();
    }
}
